# tsconfig.json

```json
{ "compilerOptions": { "target": "es5", "lib": ["dom", "dom.iterable", "esnext"], "allowJs": true, "skipLibCheck": true, "strict": true, "noEmit": true, "esModuleInterop": true, "module": "esnext", "moduleResolution": "bundler", "resolveJsonModule": true, "isolatedModules": true, "jsx": "preserve", "incremental": true, "plugins": [ { "name": "next" } ], "paths": { "@/*": ["./src/*"] } }, "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"], "exclude": ["node_modules"] }
```

# tailwind.config.js

```js
/** @type {import('tailwindcss').Config} */ module.exports = { darkMode: ["class"], content: [ './pages/**/*.{ts,tsx}', './components/**/*.{ts,tsx}', './app/**/*.{ts,tsx}', './src/**/*.{ts,tsx}', ], theme: { container: { center: true, padding: "2rem", screens: { "2xl": "1400px", }, }, extend: { colors: { border: "hsl(var(--border))", input: "hsl(var(--input))", ring: "hsl(var(--ring))", background: "hsl(var(--background))", foreground: "hsl(var(--foreground))", primary: { DEFAULT: "hsl(var(--primary))", foreground: "hsl(var(--primary-foreground))", }, secondary: { DEFAULT: "hsl(var(--secondary))", foreground: "hsl(var(--secondary-foreground))", }, destructive: { DEFAULT: "hsl(var(--destructive))", foreground: "hsl(var(--destructive-foreground))", }, muted: { DEFAULT: "hsl(var(--muted))", foreground: "hsl(var(--muted-foreground))", }, accent: { DEFAULT: "hsl(var(--accent))", foreground: "hsl(var(--accent-foreground))", }, popover: { DEFAULT: "hsl(var(--popover))", foreground: "hsl(var(--popover-foreground))", }, card: { DEFAULT: "hsl(var(--card))", foreground: "hsl(var(--card-foreground))", }, }, borderRadius: { lg: "var(--radius)", md: "calc(var(--radius) - 2px)", sm: "calc(var(--radius) - 4px)", }, keyframes: { "accordion-down": { from: { height: 0 }, to: { height: "var(--radix-accordion-content-height)" }, }, "accordion-up": { from: { height: "var(--radix-accordion-content-height)" }, to: { height: 0 }, }, }, animation: { "accordion-down": "accordion-down 0.2s ease-out", "accordion-up": "accordion-up 0.2s ease-out", }, }, }, plugins: [require("tailwindcss-animate")], }
```

# package.json

```json
{ "name": "stock-manager", "version": "0.1.0", "private": true, "scripts": { "dev": "next dev", "build": "next build", "start": "next start", "lint": "next lint", "postinstall": "prisma generate", "db:push": "prisma db push", "db:studio": "prisma studio", "db:seed": "prisma db seed", "migrate": "node --import tsx prisma/migration.ts", "migrate:currency": "node --import tsx prisma/currency-migration.ts" }, "prisma": { "seed": "ts-node --compiler-options {\"module\":\"CommonJS\"} prisma/seed.ts" }, "ts-node": { "esm": true }, "dependencies": { "@hookform/resolvers": "^3.3.2", "@prisma/client": "^5.6.0", "@radix-ui/react-alert-dialog": "^1.1.7", "@radix-ui/react-avatar": "^1.0.4", "@radix-ui/react-checkbox": "^1.1.5", "@radix-ui/react-dialog": "^1.0.5", "@radix-ui/react-dropdown-menu": "^2.0.6", "@radix-ui/react-label": "^2.0.2", "@radix-ui/react-navigation-menu": "^1.1.4", "@radix-ui/react-popover": "^1.0.7", "@radix-ui/react-select": "^2.0.0", "@radix-ui/react-separator": "^1.0.3", "@radix-ui/react-slot": "^1.0.2", "@radix-ui/react-switch": "^1.0.3", "@radix-ui/react-tabs": "^1.0.4", "@radix-ui/react-toast": "^1.1.5", "class-variance-authority": "^0.7.0", "clsx": "^2.0.0", "date-fns": "^2.30.0", "lucide-react": "^0.292.0", "next": "14.0.3", "next-themes": "^0.2.1", "react": "^18", "react-day-picker": "^8.9.1", "react-dom": "^18", "react-hook-form": "^7.48.2", "recharts": "^2.10.1", "tailwind-merge": "^2.0.0", "tailwindcss-animate": "^1.0.7", "zod": "^3.22.4" }, "devDependencies": { "@types/node": "^20", "@types/react": "^18", "@types/react-dom": "^18", "autoprefixer": "^10.0.1", "eslint": "^8", "eslint-config-next": "14.0.3", "postcss": "^8", "prisma": "^5.6.0", "tailwindcss": "^3.3.0", "ts-node": "^10.9.2", "tsx": "^4.19.3", "typescript": "^5.8.3" } }
```

# next.config.js

```js
/** @type {import('next').NextConfig} */ const nextConfig = { reactStrictMode: true, // experimental: { // Remove this block // serverActions: true, // }, } module.exports = nextConfig
```

# next-env.d.ts

```ts
/// <reference types="next" /> /// <reference types="next/image-types/global" /> // NOTE: This file should not be edited // see https://nextjs.org/docs/basic-features/typescript for more information.
```

# README.md

```md
# Personal Stock Market Manager A comprehensive, local-first stock portfolio management application built with Next.js, Prisma, and TailwindCSS. ![Stock Market Manager Dashboard](https://via.placeholder.com/1200x600?text=Stock+Manager+Dashboard) ## Features - **Dashboard**: Visual overview of portfolio value, sector allocation, and recent activity - **Stocks Management**: Track stocks with tickers, names, and sectors - **Transaction Tracking**: Record buy and sell transactions with quantity, price, and date - **Notes System**: Attach notes to stocks and transactions - **Portfolio Analytics**: View average price, total holdings, and value calculations - **Data Export**: Export transactions to CSV format - **Dark/Light Mode**: Toggle between themes for comfortable viewing - **Responsive Design**: Works on desktop and mobile devices - **Local Database**: All data stored locally in SQLite for privacy ## Tech Stack - **Frontend**: React + Next.js (App Router) - **Backend**: Next.js server actions - **Database**: SQLite (via Prisma ORM) - **ORM**: Prisma for type-safe database operations - **Styling**: TailwindCSS with shadcn/ui components - **Forms**: React Hook Form with Zod validation - **Charts**: Recharts for data visualization - **Date Handling**: date-fns for date manipulation - **Theme**: next-themes for dark/light mode ## Prerequisites - Node.js 18+ and npm - Git ## Installation 1. Clone the repository: \`\`\`bash git clone https://github.com/yourusername/stock-market-manager.git cd stock-market-manager \`\`\` 2. Install dependencies: \`\`\`bash npm install \`\`\` 3. Set up the database: \`\`\`bash npx prisma db push npx prisma generate \`\`\` 4. Seed the database with sample data: \`\`\`bash npx prisma db seed \`\`\` 5. Start the development server: \`\`\`bash npm run dev \`\`\` 6. Open your browser and navigate to http://localhost:3000 ## Usage Guide ### Dashboard The dashboard provides an overview of your portfolio with: - Total portfolio value - Sector breakdown chart - Recent transactions - Stock holdings summary ### Stocks Manage your stock information: - Add stocks with ticker symbol, company name, and sector - Filter and sort your stock list - Click on a stock to view detailed information and transaction history ### Transactions Record your stock transactions: - Log buy and sell orders - Include quantity, price per share, and transaction date - View transaction history by stock or across your portfolio ### Notes Keep track of your investment research: - Add notes to specific stocks - Add context to transactions - Review all notes in one place ### Settings Configure your application: - Update user profile information - Toggle between light and dark theme - Export transaction data to CSV - View sector categories ## Database Schema The application uses the following data models: - **User**: User profile information - **Stock**: Stock details with ticker, name, and sector - **Transaction**: Buy/sell transactions with quantity, price, and date - **Note**: Notes that can be attached to stocks or transactions - **Sector**: Industry categories for stocks - **AuditLog**: Record of major actions for data integrity ## Development ### Project Structure \`\`\` stock-manager/ ├── prisma/ # Database schema and configuration ├── public/ # Static assets └── src/ ├── actions/ # Server actions for data operations ├── app/ # Next.js App Router pages ├── components/ # React components │ ├── dashboard/ # Dashboard-specific components │ ├── layout/ # Layout components │ ├── notes/ # Note-related components │ ├── settings/ # Settings-related components │ ├── stocks/ # Stock-related components │ ├── transactions/ # Transaction-related components │ └── ui/ # UI components from shadcn/ui ├── hooks/ # Custom React hooks ├── lib/ # Utility functions and config └── providers/ # Context providers \`\`\` ### Available Scripts - `npm run dev`: Start the development server - `npm run build`: Build the application for production - `npm start`: Start the production server - `npm run lint`: Run ESLint to check for issues - `npm run db:push`: Push schema changes to the database - `npm run db:studio`: Open Prisma Studio to inspect the database - `npm run db:seed`: Seed the database with sample data ## Data Persistence All data is stored in a local SQLite database file. The database file is located at: \`\`\` prisma/dev.db \`\`\` You can back up this file to preserve your data. ## Customization ### Adding New Features To add new features: 1. Update the Prisma schema if new data models are needed 2. Create server actions in the `src/actions` directory 3. Add UI components in the `src/components` directory 4. Create routes in the `src/app` directory using the Next.js App Router ### Styling The application uses TailwindCSS for styling. You can customize the theme in: \`\`\` tailwind.config.js \`\`\` ## Troubleshooting ### Common Issues 1. **Database connection errors**: - Ensure the SQLite database file exists - Check that Prisma is properly configured 2. **UI inconsistencies**: - Clear browser cache - Ensure TailwindCSS classes are applied correctly 3. **Data not updating**: - Verify server actions are properly revalidating paths - Check browser console for errors ### Database Inspection Use Prisma Studio to directly inspect and modify the database: \`\`\`bash npx prisma studio \`\`\` ## License This project is licensed under the MIT License - see the LICENSE file for details. ## Acknowledgments - [Next.js](https://nextjs.org/) - [Prisma](https://www.prisma.io/) - [TailwindCSS](https://tailwindcss.com/) - [shadcn/ui](https://ui.shadcn.com/) - [Recharts](https://recharts.org/) --- Created by [Your Name] - [Your Website/GitHub]
```

# INITIAL_PROMPT.md

```md
### 🌟 Goal: In one shot develop a **complete, fully functional, and beautiful** personal stock market management application, designed to run **locally on a MacBook**, using **React + Next.js (App Router)**, **SQLite via Prisma ORM**, and TailwindCSS for styling. The app should enable users to track stocks, transactions, and notes with intuitive UI and clean data integrity. --- ### 🚀 Stack - **Frontend:** React + Next.js (App Router) - **Backend:** Next.js API routes or server actions using App Router conventions - **Database:** SQLite (via Prisma ORM) - **ORM:** Prisma (with strict typing, no `@db.Text`) - **Styling:** TailwindCSS (and optionally shadcn/ui for UI components) --- ### ✨ Key Features - **User Management** (even if local, add `User` model for future-proofing) - CRUD for **Stocks**, **Transactions**, and **Notes** - Notes can be linked to **stocks and/or transactions** - Real-time summary of holdings (avg price, total quantity, total value) - Dashboard with totals, sector breakdowns, recent activity - Sorting, filtering (by ticker, date, sector) - CSV Export for transactions - Dark/light mode toggle - Responsive design with smooth UI - SQLite file should be persistent and stored locally --- ### 🔧 Prisma Schema Models \`\`\`prisma model User { id String @id @default(uuid()) name String email String @unique createdAt DateTime @default(now()) stocks Stock[] transactions Transaction[] notes Note[] } model Stock { id String @id @default(uuid()) ticker String name String sectorId String? sector Sector? @relation(fields: [sectorId], references: [id]) createdAt DateTime @default(now()) userId String user User @relation(fields: [userId], references: [id]) transactions Transaction[] notes Note[] } model Transaction { id String @id @default(uuid()) stockId String stock Stock @relation(fields: [stockId], references: [id]) userId String user User @relation(fields: [userId], references: [id]) type TransactionType quantity Float price Float date DateTime notes Note[] } enum TransactionType { BUY SELL } model Note { id String @id @default(uuid()) content String createdAt DateTime @default(now()) stockId String? stock Stock? @relation(fields: [stockId], references: [id]) transactionId String? transaction Transaction? @relation(fields: [transactionId], references: [id]) userId String user User @relation(fields: [userId], references: [id]) } model Sector { id String @id @default(uuid()) name String @unique stocks Stock[] } model AuditLog { id String @id @default(uuid()) action String // e.g., CREATE_TRANSACTION entityType String // Stock | Transaction | Note entityId String payload String // optional JSON timestamp DateTime @default(now()) userId String } \`\`\` --- ### ⚡ App Requirements - Use `"use client"` in any interactive components (forms, modals, etc.) - Server actions or API routes should handle all DB mutations - Use `react-hook-form` or `useFormState` for UX - Tailwind + shadcn/ui for clean and consistent design - Persist state using Prisma and SQLite - Show computed fields (e.g., average buy price per stock)
```

# .gitignore

```
# Dependencies /node_modules /.pnp .pnp.js package-lock.json yarn.lock .yarn/* !.yarn/patches !.yarn/plugins !.yarn/releases !.yarn/sdks !.yarn/versions # Testing /coverage /.nyc_output /cypress/videos/ /cypress/screenshots/ # Next.js /.next/ /out/ /build .swc/ .turbo # Production /dist /build # Debug npm-debug.log* yarn-debug.log* yarn-error.log* .pnpm-debug.log* # Local env files .env .env.local .env.development.local .env.test.local .env.production.local # Vercel .vercel # Typescript *.tsbuildinfo next-env.d.ts # Editor directories and files .idea/ .vscode/* !.vscode/extensions.json !.vscode/launch.json !.vscode/settings.json .DS_Store *.suo *.ntvs* *.njsproj *.sln *.sw? .project .classpath .c9/ *.launch .settings/ *.sublime-workspace .history .prettierrc # Database Files *.sqlite *.sqlite3 *.db *.db-journal /prisma/dev.db /prisma/dev.db-journal # Log files logs *.log # OS generated files Thumbs.db .DS_Store ehthumbs.db ehthumbs_vista.db Desktop.ini $RECYCLE.BIN/ .fseventsd # Deployment artifacts .netlify/ _static/ # Temporary files *.tmp *.temp .cache/ # Build artifacts .next /public/workbox-*.js /public/sw.js /public/fallback-*.js # ESLint .eslintcache # Storybook /storybook-static # Jest jest.config.js.bak
```

# prisma/seed.ts

```ts
import { PrismaClient } from '@prisma/client'; import { addDays, subDays } from 'date-fns'; import { TransactionType } from '../src/lib/constants'; const prisma = new PrismaClient(); async function main() { // Create default user const defaultUserName = process.env.DEFAULT_USER_NAME || 'Demo User'; const defaultUserEmail = process.env.DEFAULT_USER_EMAIL || 'user@example.com'; // Create user if not exists const user = await prisma.user.upsert({ where: { email: defaultUserEmail }, update: { defaultCurrency: 'GBP', // Update with default currency }, create: { name: defaultUserName, email: defaultUserEmail, defaultCurrency: 'GBP', // Set default currency }, }); console.log(`Default user created or found with ID: ${user.id}`); // Create sectors const sectors = await Promise.all([ 'Technology', 'Healthcare', 'Financial Services', 'Consumer Goods', 'Energy', 'Utilities', 'Real Estate', 'Communication Services', 'Materials', 'Industrials', ].map(async (name) => { return await prisma.sector.upsert({ where: { name }, update: {}, create: { name }, }); })); console.log(`Created or found ${sectors.length} sectors`); // Create sample stocks const techSector = sectors[0]; const financeSector = sectors[2]; const stocks = await Promise.all([ { ticker: 'AAPL', name: 'Apple Inc.', sectorId: techSector.id, userId: user.id, currency: 'USD', // Set currency for stock }, { ticker: 'MSFT', name: 'Microsoft Corporation', sectorId: techSector.id, userId: user.id, currency: 'USD', // Set currency for stock }, { ticker: 'JPM', name: 'JPMorgan Chase & Co.', sectorId: financeSector.id, userId: user.id, currency: 'USD', // Set currency for stock }, { ticker: 'BARC', name: 'Barclays PLC', sectorId: financeSector.id, userId: user.id, currency: 'GBP', // Set a GBP stock as example }, ].map(async (stock) => { return await prisma.stock.upsert({ where: { id: `${stock.userId}-${stock.ticker}`, // This will fail, but we'll catch it }, update: { currency: stock.currency, // Update currency if stock exists }, create: stock, select: { id: true, ticker: true, currency: true, }, }).catch(() => { // If the upsert fails (since we don't have a compound unique constraint), // we'll create a new stock return prisma.stock.create({ data: stock, select: { id: true, ticker: true, currency: true, }, }); }); })); console.log(`Created sample stocks: ${stocks.map(s => s.ticker).join(', ')}`); // Create sample transactions const today = new Date(); // Regular transactions with various currencies for (const stock of stocks) { // Determine the currency for this stock's transactions const stockCurrency = stock.currency; // Create a BUY transaction await prisma.transaction.create({ data: { stockId: stock.id, userId: user.id, type: TransactionType.BUY, quantity: 10, price: stock.ticker === 'AAPL' ? 175.5 : stock.ticker === 'MSFT' ? 340.2 : stock.ticker === 'BARC' ? 150.75 : 150.75, currency: stockCurrency, // Use the stock's currency exchangeRate: stockCurrency === 'GBP' ? 1.0 : 1.25, // Exchange rate from USD to GBP if needed fxFee: stockCurrency === 'GBP' ? 0.0 : 5.0, // FX fee for foreign currency date: subDays(today, Math.floor(Math.random() * 30)), } }); // Create another BUY transaction await prisma.transaction.create({ data: { stockId: stock.id, userId: user.id, type: TransactionType.BUY, quantity: 5, price: stock.ticker === 'AAPL' ? 180.25 : stock.ticker === 'MSFT' ? 345.8 : stock.ticker === 'BARC' ? 155.3 : 155.3, currency: stockCurrency, // Use the stock's currency exchangeRate: stockCurrency === 'GBP' ? 1.0 : 1.27, // Exchange rate from USD to GBP if needed fxFee: stockCurrency === 'GBP' ? 0.0 : 4.5, // FX fee for foreign currency date: subDays(today, Math.floor(Math.random() * 20)), } }); // Create a SELL transaction for AAPL and BARC only if (stock.ticker === 'AAPL' || stock.ticker === 'BARC') { await prisma.transaction.create({ data: { stockId: stock.id, userId: user.id, type: TransactionType.SELL, quantity: 3, price: stock.ticker === 'AAPL' ? 190.5 : 165.25, currency: stockCurrency, // Use the stock's currency exchangeRate: stockCurrency === 'GBP' ? 1.0 : 1.26, // Exchange rate from USD to GBP if needed fxFee: stockCurrency === 'GBP' ? 0.0 : 4.75, // FX fee for foreign currency date: subDays(today, Math.floor(Math.random() * 10)), } }); } } console.log('Created sample transactions with currency information'); // Create sample notes await prisma.note.create({ data: { content: 'Apple showing strong growth potential after recent product launch', userId: user.id, stockId: stocks[0].id, } }); await prisma.note.create({ data: { content: 'Microsoft cloud services continue to exceed expectations', userId: user.id, stockId: stocks[1].id, } }); // Add a note about currency considerations const barcStock = stocks.find(s => s.ticker === 'BARC'); if (barcStock) { await prisma.note.create({ data: { content: 'UK stock with no currency conversion needed as it trades in GBP', userId: user.id, stockId: barcStock.id, } }); } // Add a note about foreign currency transaction const msftStock = stocks.find(s => s.ticker === 'MSFT'); if (msftStock) { await prisma.note.create({ data: { content: 'Need to monitor USD/GBP exchange rates for impact on returns', userId: user.id, stockId: msftStock.id, } }); } console.log('Created sample notes'); // Create some audit logs await prisma.auditLog.create({ data: { action: 'CREATE_STOCK', entityType: 'Stock', entityId: stocks[0].id, payload: JSON.stringify({ ticker: 'AAPL', name: 'Apple Inc.', currency: 'USD' }), userId: user.id, } }); console.log('Created sample audit logs'); } main() .then(async () => { await prisma.$disconnect(); }) .catch(async (e) => { console.error(e); await prisma.$disconnect(); process.exit(1); });
```

# prisma/schema.prisma

```prisma
// This is your Prisma schema file, // learn more about it in the docs: https://pris.ly/d/prisma-schema generator client { provider = "prisma-client-js" } datasource db { provider = "sqlite" url = env("DATABASE_URL") } model User { id String @id @default(uuid()) name String email String @unique createdAt DateTime @default(now()) stocks Stock[] transactions Transaction[] notes Note[] defaultCurrency String @default("GBP") // Default currency for the user } model Stock { id String @id @default(uuid()) ticker String name String sectorId String? sector Sector? @relation(fields: [sectorId], references: [id]) createdAt DateTime @default(now()) userId String user User @relation(fields: [userId], references: [id]) transactions Transaction[] notes Note[] currency String @default("USD") // Currency for the stock @@unique([userId, ticker]) } model Transaction { id String @id @default(uuid()) stockId String stock Stock @relation(fields: [stockId], references: [id]) userId String user User @relation(fields: [userId], references: [id]) type String // 'BUY' or 'SELL' - replacing enum with string quantity Float price Float currency String @default("USD") // Currency for the transaction price exchangeRate Float // Exchange rate for foreign currency transactions (no longer optional) fxFee Float // Foreign exchange fee (no longer optional) date DateTime notes Note[] } model Note { id String @id @default(uuid()) content String createdAt DateTime @default(now()) stockId String? stock Stock? @relation(fields: [stockId], references: [id]) transactionId String? transaction Transaction? @relation(fields: [transactionId], references: [id]) userId String user User @relation(fields: [userId], references: [id]) } model Sector { id String @id @default(uuid()) name String @unique stocks Stock[] } model AuditLog { id String @id @default(uuid()) action String // e.g., CREATE_TRANSACTION entityType String // Stock | Transaction | Note entityId String payload String // optional JSON timestamp DateTime @default(now()) userId String }
```

# prisma/migration.ts

```ts
// prisma/migration.ts import { PrismaClient } from '@prisma/client'; const prisma = new PrismaClient(); async function migrate() { try { console.log('Starting migration to add or update exchangeRate and fxFee fields...'); // Apply migration by setting default values console.log('Updating all existing transactions with default values...'); const transactions = await prisma.transaction.findMany(); let updated = 0; for (const transaction of transactions) { try { await prisma.transaction.update({ where: { id: transaction.id }, data: { // Set default values if not already set exchangeRate: transaction.exchangeRate ?? 1.0, fxFee: transaction.fxFee ?? 0.0, }, }); updated++; } catch (error) { console.error(`Error updating transaction ${transaction.id}:`, error); } } console.log(`Migration complete! Updated ${updated} of ${transactions.length} transactions.`); } catch (error) { console.error('Migration failed:', error); } finally { await prisma.$disconnect(); } } // Run the migration migrate().catch(console.error);
```

# prisma/migration.js

```js
// migration.js const { PrismaClient } = require('@prisma/client'); const prisma = new PrismaClient(); async function migrate() { try { console.log('Starting migration to add exchange rate and FX fee fields...'); const transactions = await prisma.transaction.findMany(); let updated = 0; for (const transaction of transactions) { try { await prisma.transaction.update({ where: { id: transaction.id }, data: { exchangeRate: 1.0, // Default to 1.0 (no conversion) fxFee: 0.0, // Default to no fee }, }); updated++; } catch (error) { console.error(`Error updating transaction ${transaction.id}:`, error); } } console.log(`Migration complete! Updated ${updated} of ${transactions.length} transactions.`); } catch (error) { console.error('Migration failed:', error); } finally { await prisma.$disconnect(); } } // Run the migration migrate().catch(console.error);
```

# prisma/dev.db

This is a binary file of the type: Binary

# prisma/dedupe-stocks.ts

```ts
/** * Delete duplicate stocks per (userId,ticker) pair and * move their transactions onto the first keep‑record. * * Usage: npx ts-node prisma/dedupe-stocks.ts */ import { PrismaClient } from "@prisma/client"; const prisma = new PrismaClient(); async function main() { const users = await prisma.user.findMany({ select: { id: true } }); for (const { id: userId } of users) { // group by ticker const stocks = await prisma.stock.findMany({ where: { userId }, orderBy: { createdAt: "asc" }, // oldest first }); const groups = stocks.reduce<Record<string, typeof stocks>>( (acc, s) => { (acc[s.ticker] ||= []).push(s); return acc; }, {}, ); for (const [ticker, duplicates] of Object.entries(groups)) { if (duplicates.length <= 1) continue; const [keep, ...remove] = duplicates; // move transactions await prisma.transaction.updateMany({ where: { stockId: { in: remove.map((s) => s.id) } }, data: { stockId: keep.id }, }); // move notes await prisma.note.updateMany({ where: { stockId: { in: remove.map((s) => s.id) } }, data: { stockId: keep.id }, }); // delete duplicates await prisma.stock.deleteMany({ where: { id: { in: remove.map((s) => s.id) } }, }); console.log( `Merged ${remove.length} duplicate ${ticker} rows into ${keep.id}`, ); } } } main().finally(() => prisma.$disconnect());
```

# prisma/currency-migration.ts

```ts
// prisma/currency-migration.ts import { PrismaClient } from '@prisma/client'; const prisma = new PrismaClient(); async function migrate() { try { console.log('Starting migration to add currency fields...'); // Add default currency to User model console.log('Updating all existing users with default currency (GBP)...'); const usersUpdated = await prisma.user.updateMany({ data: { defaultCurrency: 'GBP', }, }); console.log(`Updated ${usersUpdated.count} users.`); // Add currency to Stock model console.log('Updating all existing stocks with default currency (USD)...'); const stocksUpdated = await prisma.stock.updateMany({ data: { currency: 'USD', }, }); console.log(`Updated ${stocksUpdated.count} stocks.`); // Add currency to Transaction model console.log('Updating all existing transactions with default currency (USD)...'); const transactionsUpdated = await prisma.transaction.updateMany({ data: { currency: 'USD', }, }); console.log(`Updated ${transactionsUpdated.count} transactions.`); console.log('Migration complete!'); } catch (error) { console.error('Migration failed:', error); } finally { await prisma.$disconnect(); } } // Run the migration migrate().catch(console.error);
```

# src/types/index.ts

```ts

```

# src/providers/theme-provider.tsx

```tsx
"use client"; import * as React from "react"; import { ThemeProvider as NextThemesProvider } from "next-themes"; import { type ThemeProviderProps } from "next-themes/dist/types"; export function ThemeProvider({ children, ...props }: ThemeProviderProps) { return <NextThemesProvider {...props}>{children}</NextThemesProvider>; }
```

# src/providers/auth-provider.tsx

```tsx

```

# src/lib/validators.ts

```ts
import { z } from "zod"; import { TransactionType, TransactionTypeValue } from "./constants"; // Currency validation const currencyEnum = z.enum(["GBP", "USD", "EUR", "JPY", "CHF", "CAD", "AUD"]); export type Currency = z.infer<typeof currencyEnum>; // Stock validation schema export const stockSchema = z.object({ ticker: z.string().min(1, "Ticker is required").max(10, "Ticker must be 10 characters or less").toUpperCase(), name: z.string().min(1, "Company name is required").max(100, "Company name must be 100 characters or less"), sectorId: z.string().optional(), currency: currencyEnum.default("USD"), }); // Stock with note validation schema export const stockWithNoteSchema = stockSchema.extend({ includeNote: z.boolean().default(false), noteContent: z.string().max(1000, "Note must be 1000 characters or less").optional(), }).refine( (data) => !data.includeNote || (data.includeNote && data.noteContent && data.noteContent.length > 0), { message: "Note content is required when including a note", path: ["noteContent"], } ); export type StockFormValues = z.infer<typeof stockSchema>; // Transaction validation schema export const transactionSchema = z.object({ stockId: z.string().min(1, "Stock is required"), type: z.enum([TransactionType.BUY, TransactionType.SELL], { errorMap: () => ({ message: "Transaction type is required" }), }), quantity: z.number().positive("Quantity must be positive"), price: z.number().positive("Price must be positive"), currency: currencyEnum.default("USD"), exchangeRate: z.number().positive("Exchange rate must be positive").optional(), fxFee: z.number().min(0, "FX fee must be non-negative").optional(), date: z.date({ required_error: "Date is required", invalid_type_error: "That's not a valid date", }), }); // Transaction with note validation schema export const transactionWithNoteSchema = transactionSchema.extend({ includeNote: z.boolean().default(false), noteContent: z.string().max(1000, "Note must be 1000 characters or less").optional(), }).refine( (data) => !data.includeNote || (data.includeNote && data.noteContent && data.noteContent.length > 0), { message: "Note content is required when including a note", path: ["noteContent"], } ); export type TransactionFormValues = z.infer<typeof transactionSchema>; export type TransactionWithNoteFormValues = z.infer<typeof transactionWithNoteSchema>; // Note validation schema export const noteSchema = z.object({ content: z.string().min(1, "Content is required").max(1000, "Content must be 1000 characters or less"), stockId: z.string().optional(), transactionId: z.string().optional(), }); export type NoteFormValues = z.infer<typeof noteSchema>; // Sector validation schema export const sectorSchema = z.object({ name: z.string().min(1, "Sector name is required").max(100, "Sector name must be 100 characters or less"), }); export type SectorFormValues = z.infer<typeof sectorSchema>; // User profile validation schema export const userProfileSchema = z.object({ name: z.string().min(1, "Name is required").max(100, "Name must be 100 characters or less"), email: z.string().email("Invalid email address"), defaultCurrency: currencyEnum.default("GBP"), }); export type StockWithNoteFormValues = z.infer<typeof stockWithNoteSchema>; export type UserProfileFormValues = z.infer<typeof userProfileSchema>;
```

# src/lib/utils.ts

```ts
import { type ClassValue, clsx } from "clsx"; import { twMerge } from "tailwind-merge"; import { TransactionType } from "./constants"; import { Currency } from "./validators"; /** * Combines class names with tailwind merge */ export function cn(...inputs: ClassValue[]) { return twMerge(clsx(inputs)); } /** * Gets the currency symbol for a currency code */ export function getCurrencySymbol(currency: Currency | string = 'GBP'): string { const symbols: { [key: string]: string } = { 'GBP': '£', 'USD': '$', 'EUR': '€', 'JPY': '¥', 'CHF': 'Fr', 'CAD': 'C$', 'AUD': 'A$', }; return symbols[currency] || currency; } /** * Formats a number as currency */ export function formatCurrency(amount: number, currency: Currency | string = 'GBP'): string { const locale = currency === 'GBP' ? 'en-GB' : 'en-US'; return new Intl.NumberFormat(locale, { style: 'currency', currency: currency, }).format(amount); } /** * Formats a date */ export function formatDate(date: Date): string { return new Intl.DateTimeFormat('en-GB', { year: 'numeric', month: 'short', day: 'numeric', }).format(date); } /** * Calculates the total cost or proceeds of a transaction, including FX fees if applicable */ export function calculateTransactionTotal(transaction: { quantity: number; price: number; type: string; currency?: string; exchangeRate?: number | null; fxFee?: number | null; }): number { const baseAmount = transaction.quantity * transaction.price; // If there's an exchange rate, convert the amount const convertedAmount = transaction.exchangeRate ? baseAmount * transaction.exchangeRate : baseAmount; // For BUY transactions, add FX fee; for SELL transactions, subtract FX fee if (transaction.fxFee) { if (transaction.type === TransactionType.BUY) { return convertedAmount + transaction.fxFee; } else { return convertedAmount - transaction.fxFee; } } return convertedAmount; } /** * Calculates average purchase price for a stock based on transactions */ export function calculateAveragePrice(transactions: { type: string; quantity: number; price: number; currency?: string; exchangeRate?: number | null; }[]): number { const buyTransactions = transactions.filter( (transaction) => transaction.type === TransactionType.BUY ); if (buyTransactions.length === 0) return 0; const totalCost = buyTransactions.reduce( (sum, transaction) => { // Apply exchange rate if available const convertedPrice = transaction.exchangeRate ? transaction.price * transaction.exchangeRate : transaction.price; return sum + transaction.quantity * convertedPrice; }, 0 ); const totalQuantity = buyTransactions.reduce( (sum, transaction) => sum + transaction.quantity, 0 ); return totalCost / totalQuantity; } /** * Calculates total holdings (quantity) for a stock based on transactions */ export function calculateTotalHoldings(transactions: { type: string; quantity: number; }[]): number { return transactions.reduce((total, transaction) => { if (transaction.type === TransactionType.BUY) { return total + transaction.quantity; } else { return total - transaction.quantity; } }, 0); } /** * Creates a GUID */ export function generateId(): string { return crypto.randomUUID(); } /** * Create an audit log entry */ export async function createAuditLog(prisma: any, { action, entityType, entityId, userId, payload, }: { action: string; entityType: string; entityId: string; userId: string; payload?: any; }) { return prisma.auditLog.create({ data: { action, entityType, entityId, userId, payload: payload ? JSON.stringify(payload) : "", } }); } /** * Exports data to CSV format */ export function exportToCSV(data: any[], filename: string) { // Convert data to CSV format const csvRows = []; // Get headers const headers = Object.keys(data[0]); csvRows.push(headers.join(',')); // Add data rows for (const row of data) { const values = headers.map(header => { const value = row[header]; // Handle special cases (dates, objects, etc.) if (value instanceof Date) { return `"${formatDate(value)}"`; } else if (typeof value === 'string') { // Escape quotes and wrap in quotes return `"${value.replace(/"/g, '""')}"`; } else if (typeof value === 'object' && value !== null) { return `"${JSON.stringify(value).replace(/"/g, '""')}"`; } return value; }); csvRows.push(values.join(',')); } // Create blob and download link const csvString = csvRows.join('\n'); const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8;' }); if (typeof window !== 'undefined') { const url = URL.createObjectURL(blob); const link = document.createElement('a'); link.setAttribute('href', url); link.setAttribute('download', filename); link.style.visibility = 'hidden'; document.body.appendChild(link); link.click(); document.body.removeChild(link); } return csvString; }
```

# src/lib/db.ts

```ts
import { PrismaClient } from '@prisma/client'; // PrismaClient is attached to the `global` object in development to prevent // exhausting your database connection limit. // Learn more: https://pris.ly/d/help/next-js-best-practices const globalForPrisma = global as unknown as { prisma: PrismaClient }; export const prisma = globalForPrisma.prisma || new PrismaClient(); if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma; export default prisma;
```

# src/lib/constants.ts

```ts
// Define transaction types as string constants to replace enum export const TransactionType = { BUY: 'BUY', SELL: 'SELL', } as const; export type TransactionTypeValue = typeof TransactionType[keyof typeof TransactionType];
```

# src/hooks/use-toast.ts

```ts
// Inspired by react-hot-toast library import * as React from "react" import type { ToastActionElement, ToastProps } from "@/components/ui/toast" const TOAST_LIMIT = 5 const TOAST_REMOVE_DELAY = 1000000 type ToasterToast = ToastProps & { id: string title?: React.ReactNode description?: React.ReactNode action?: ToastActionElement } const actionTypes = { ADD_TOAST: "ADD_TOAST", UPDATE_TOAST: "UPDATE_TOAST", DISMISS_TOAST: "DISMISS_TOAST", REMOVE_TOAST: "REMOVE_TOAST", } as const let count = 0 function genId() { count = (count + 1) % Number.MAX_VALUE return count.toString() } type ActionType = typeof actionTypes type Action = | { type: ActionType["ADD_TOAST"] toast: ToasterToast } | { type: ActionType["UPDATE_TOAST"] toast: Partial<ToasterToast> } | { type: ActionType["DISMISS_TOAST"] toastId?: ToasterToast["id"] } | { type: ActionType["REMOVE_TOAST"] toastId?: ToasterToast["id"] } interface State { toasts: ToasterToast[] } const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>() const addToRemoveQueue = (toastId: string) => { if (toastTimeouts.has(toastId)) { return } const timeout = setTimeout(() => { toastTimeouts.delete(toastId) dispatch({ type: "REMOVE_TOAST", toastId: toastId, }) }, TOAST_REMOVE_DELAY) toastTimeouts.set(toastId, timeout) } export const reducer = (state: State, action: Action): State => { switch (action.type) { case "ADD_TOAST": return { ...state, toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT), } case "UPDATE_TOAST": return { ...state, toasts: state.toasts.map((t) => t.id === action.toast.id ? { ...t, ...action.toast } : t ), } case "DISMISS_TOAST": { const { toastId } = action // ! Side effects ! - This could be extracted into a dismissToast() action, // but I'll keep it here for simplicity if (toastId) { addToRemoveQueue(toastId) } else { state.toasts.forEach((toast) => { addToRemoveQueue(toast.id) }) } return { ...state, toasts: state.toasts.map((t) => t.id === toastId || toastId === undefined ? { ...t, open: false, } : t ), } } case "REMOVE_TOAST": if (action.toastId === undefined) { return { ...state, toasts: [], } } return { ...state, toasts: state.toasts.filter((t) => t.id !== action.toastId), } } } const listeners: Array<(state: State) => void> = [] let memoryState: State = { toasts: [] } function dispatch(action: Action) { memoryState = reducer(memoryState, action) listeners.forEach((listener) => { listener(memoryState) }) } interface Toast extends Omit<ToasterToast, "id"> { } function toast({ ...props }: Toast) { const id = genId() const update = (props: ToasterToast) => dispatch({ type: "UPDATE_TOAST", toast: { ...props, id }, }) const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id }) dispatch({ type: "ADD_TOAST", toast: { ...props, id, open: true, onOpenChange: (open) => { if (!open) dismiss() }, }, }) return { id: id, dismiss, update, } } function useToast() { const [state, setState] = React.useState<State>(memoryState) React.useEffect(() => { listeners.push(setState) return () => { const index = listeners.indexOf(setState) if (index > -1) { listeners.splice(index, 1) } } }, [state]) return { ...state, toast, dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }), } } export { useToast, toast }
```

# src/hooks/use-form.ts

```ts

```

# src/app/page.tsx

```tsx
import Link from "next/link"; import { redirect } from "next/navigation"; import { Button } from "@/components/ui/button"; import { LineChart, BarChart3, CreditCard, BookOpen, Settings } from "lucide-react"; export default function HomePage() { // Redirect to dashboard by default redirect("/dashboard"); // This code won't execute due to the redirect, but we'll include it for completeness return ( <div className="flex items-center justify-center min-h-[80vh]"> <div className="text-center space-y-6 max-w-2xl px-4"> <LineChart className="mx-auto h-16 w-16" /> <h1 className="text-4xl font-bold">Welcome to Stock Manager</h1> <p className="text-xl text-muted-foreground"> Track your stock portfolio, manage transactions, and keep notes all in one place. </p> <div className="grid gap-4 md:grid-cols-2 mt-8"> <div className="border rounded-lg p-6 text-left space-y-4"> <BarChart3 className="h-8 w-8" /> <h2 className="text-xl font-semibold">Dashboard</h2> <p className="text-sm text-muted-foreground"> Get a visual overview of your portfolio value and sector allocation. </p> <Link href="/dashboard"> <Button size="sm">View Dashboard</Button> </Link> </div> <div className="border rounded-lg p-6 text-left space-y-4"> <LineChart className="h-8 w-8" /> <h2 className="text-xl font-semibold">Stocks</h2> <p className="text-sm text-muted-foreground"> Manage your stock holdings and view detailed information. </p> <Link href="/stocks"> <Button size="sm">View Stocks</Button> </Link> </div> <div className="border rounded-lg p-6 text-left space-y-4"> <CreditCard className="h-8 w-8" /> <h2 className="text-xl font-semibold">Transactions</h2> <p className="text-sm text-muted-foreground"> Record buy and sell transactions for your portfolio. </p> <Link href="/transactions"> <Button size="sm">View Transactions</Button> </Link> </div> <div className="border rounded-lg p-6 text-left space-y-4"> <BookOpen className="h-8 w-8" /> <h2 className="text-xl font-semibold">Notes</h2> <p className="text-sm text-muted-foreground"> Keep track of your investment research and ideas. </p> <Link href="/notes"> <Button size="sm">View Notes</Button> </Link> </div> </div> <div className="mt-8"> <Link href="/settings"> <Button variant="outline"> <Settings className="mr-2 h-4 w-4" /> Settings </Button> </Link> </div> </div> </div> ); }
```

# src/app/layout.tsx

```tsx
import type { Metadata } from 'next'; import { Inter } from 'next/font/google'; import './globals.css'; import { ThemeProvider } from '@/providers/theme-provider'; import Navigation from '@/components/layout/navigation'; import { Toaster } from '@/components/ui/toaster'; const inter = Inter({ subsets: ['latin'] }); export const metadata: Metadata = { title: 'Stock Market Manager', description: 'Manage your stock portfolio with ease', }; export default function RootLayout({ children, }: { children: React.ReactNode; }) { return ( <html lang="en" suppressHydrationWarning> <body className={inter.className}> <ThemeProvider attribute="class" defaultTheme="system" enableSystem disableTransitionOnChange > <div className="flex min-h-screen flex-col"> <Navigation /> <main className="flex-1 container mx-auto py-6 px-4 md:px-6"> {children} </main> <footer className="border-t py-4"> <div className="container mx-auto text-center text-sm text-muted-foreground"> &copy; {new Date().getFullYear()} - Personal Stock Manager </div> </footer> </div> <Toaster /> </ThemeProvider> </body> </html> ); }
```

# src/app/globals.css

```css
@tailwind base; @tailwind components; @tailwind utilities; @layer base { :root { --background: 0 0% 100%; --foreground: 222.2 84% 4.9%; --card: 0 0% 100%; --card-foreground: 222.2 84% 4.9%; --popover: 0 0% 100%; --popover-foreground: 222.2 84% 4.9%; --primary: 222.2 47.4% 11.2%; --primary-foreground: 210 40% 98%; --secondary: 210 40% 96.1%; --secondary-foreground: 222.2 47.4% 11.2%; --muted: 210 40% 96.1%; --muted-foreground: 215.4 16.3% 46.9%; --accent: 210 40% 96.1%; --accent-foreground: 222.2 47.4% 11.2%; --destructive: 0 84.2% 60.2%; --destructive-foreground: 210 40% 98%; --border: 214.3 31.8% 91.4%; --input: 214.3 31.8% 91.4%; --ring: 222.2 84% 4.9%; --radius: 0.5rem; } .dark { --background: 222.2 84% 4.9%; --foreground: 210 40% 98%; --card: 222.2 84% 4.9%; --card-foreground: 210 40% 98%; --popover: 222.2 84% 4.9%; --popover-foreground: 210 40% 98%; --primary: 210 40% 98%; --primary-foreground: 222.2 47.4% 11.2%; --secondary: 217.2 32.6% 17.5%; --secondary-foreground: 210 40% 98%; --muted: 217.2 32.6% 17.5%; --muted-foreground: 215 20.2% 65.1%; --accent: 217.2 32.6% 17.5%; --accent-foreground: 210 40% 98%; --destructive: 0 62.8% 30.6%; --destructive-foreground: 210 40% 98%; --border: 217.2 32.6% 17.5%; --input: 217.2 32.6% 17.5%; --ring: 212.7 26.8% 83.9%; } } @layer base { * { @apply border-border; } body { @apply bg-background text-foreground; } }
```

# src/actions/user.ts

```ts
"use server"; import { prisma } from "@/lib/db"; import { UserProfileFormValues } from "@/lib/validators"; import { revalidatePath } from "next/cache"; /** * Get the current user (for local development, we'll use the default user) */ export async function getCurrentUser() { const defaultUserEmail = process.env.DEFAULT_USER_EMAIL || "user@example.com"; const user = await prisma.user.findUnique({ where: { email: defaultUserEmail }, }); if (!user) { throw new Error("No user found. Please ensure the seed script has been run."); } return user; } /** * Update user profile */ export async function updateUserProfile(data: UserProfileFormValues) { try { const currentUser = await getCurrentUser(); const updatedUser = await prisma.user.update({ where: { id: currentUser.id }, data: { name: data.name, email: data.email, defaultCurrency: data.defaultCurrency, }, }); revalidatePath("/settings"); return { success: true, user: updatedUser }; } catch (error) { console.error("Error updating user profile:", error); return { success: false, error: "Failed to update profile" }; } }
```

# src/actions/transactions.ts

```ts
"use server"; import { prisma } from "@/lib/db"; import { TransactionFormValues } from "@/lib/validators"; import { createAuditLog } from "@/lib/utils"; import { getCurrentUser } from "./user"; import { revalidatePath } from "next/cache"; /** * Get all transactions for the current user */ export async function getTransactions() { try { const user = await getCurrentUser(); const transactions = await prisma.transaction.findMany({ where: { userId: user.id }, include: { stock: true, notes: { select: { id: true, content: true, }, orderBy: { createdAt: "desc", }, }, }, orderBy: { date: "desc" }, }); return { success: true, data: transactions }; } catch (error) { console.error("Error getting transactions:", error); return { success: false, error: "Failed to fetch transactions" }; } } /** * Get a transaction by ID */ export async function getTransactionById(id: string) { try { const user = await getCurrentUser(); const transaction = await prisma.transaction.findFirst({ where: { id, userId: user.id, }, include: { stock: true, notes: { orderBy: { createdAt: "desc" }, }, }, }); if (!transaction) { return { success: false, error: "Transaction not found" }; } return { success: true, data: transaction }; } catch (error) { console.error("Error getting transaction:", error); return { success: false, error: "Failed to fetch transaction" }; } } /** * Create a new transaction */ export async function createTransaction(data: TransactionFormValues) { try { const user = await getCurrentUser(); // Check if stock exists and belongs to user const stock = await prisma.stock.findFirst({ where: { id: data.stockId, userId: user.id, }, }); if (!stock) { return { success: false, error: "Stock not found" }; } // Get user's default currency const userCurrency = user.defaultCurrency || "GBP"; // Determine if we need currency conversion const needsConversion = data.currency !== userCurrency; // Create the transaction with required exchangeRate and fxFee const transaction = await prisma.transaction.create({ data: { stockId: data.stockId, userId: user.id, type: data.type, quantity: data.quantity, price: data.price, currency: data.currency || stock.currency, // Use stock currency if not specified exchangeRate: needsConversion ? (data.exchangeRate || 1) : 1, fxFee: needsConversion ? (data.fxFee || 0) : 0, date: data.date, }, include: { stock: true, }, }); // Create audit log await createAuditLog(prisma, { action: "CREATE_TRANSACTION", entityType: "Transaction", entityId: transaction.id, userId: user.id, payload: { stockTicker: transaction.stock.ticker, type: transaction.type, quantity: transaction.quantity, price: transaction.price, currency: transaction.currency, exchangeRate: transaction.exchangeRate, fxFee: transaction.fxFee, }, }); revalidatePath("/transactions"); revalidatePath(`/stocks/${data.stockId}`); revalidatePath("/dashboard"); return { success: true, data: transaction }; } catch (error) { console.error("Error creating transaction:", error); return { success: false, error: "Failed to create transaction" }; } } /** * Update a transaction */ export async function updateTransaction(id: string, data: TransactionFormValues) { try { const user = await getCurrentUser(); // Check if transaction exists and belongs to user const transaction = await prisma.transaction.findFirst({ where: { id, userId: user.id, }, include: { stock: true, }, }); if (!transaction) { return { success: false, error: "Transaction not found" }; } // Check if stock exists and belongs to user const stock = await prisma.stock.findFirst({ where: { id: data.stockId, userId: user.id, }, }); if (!stock) { return { success: false, error: "Stock not found" }; } // Get user's default currency const userCurrency = user.defaultCurrency || "GBP"; // Determine if we need currency conversion const needsConversion = (data.currency || stock.currency) !== userCurrency; // Update the transaction - using direct update because our fields match the schema const updatedTransaction = await prisma.transaction.update({ where: { id }, data: { type: data.type, quantity: data.quantity, price: data.price, date: data.date, // Only update stockId if it has changed ...(transaction.stockId !== data.stockId ? { stockId: data.stockId } : {}), // Always include these fields currency: data.currency || transaction.currency, exchangeRate: needsConversion ? (data.exchangeRate || 1) : 1, fxFee: needsConversion ? (data.fxFee || 0) : 0, }, include: { stock: true, }, }); // Create audit log await createAuditLog(prisma, { action: "UPDATE_TRANSACTION", entityType: "Transaction", entityId: updatedTransaction.id, userId: user.id, payload: { stockTicker: updatedTransaction.stock.ticker, type: updatedTransaction.type, quantity: updatedTransaction.quantity, price: updatedTransaction.price, currency: updatedTransaction.currency, exchangeRate: updatedTransaction.exchangeRate, fxFee: updatedTransaction.fxFee, }, }); revalidatePath("/transactions"); revalidatePath(`/transactions/${id}`); revalidatePath(`/stocks/${transaction.stockId}`); if (transaction.stockId !== data.stockId) { revalidatePath(`/stocks/${data.stockId}`); } revalidatePath("/dashboard"); return { success: true, data: updatedTransaction }; } catch (error) { console.error("Error updating transaction:", error); return { success: false, error: "Failed to update transaction" }; } } /** * Delete a transaction */ export async function deleteTransaction(id: string) { try { const user = await getCurrentUser(); // Check if transaction exists and belongs to user const transaction = await prisma.transaction.findFirst({ where: { id, userId: user.id, }, include: { stock: true, notes: true, }, }); if (!transaction) { return { success: false, error: "Transaction not found" }; } // Delete related notes if (transaction.notes.length > 0) { await prisma.note.deleteMany({ where: { transactionId: id, }, }); } // Delete the transaction await prisma.transaction.delete({ where: { id }, }); // Create audit log await createAuditLog(prisma, { action: "DELETE_TRANSACTION", entityType: "Transaction", entityId: id, userId: user.id, payload: { stockTicker: transaction.stock.ticker, type: transaction.type, currency: transaction.currency, }, }); revalidatePath("/transactions"); revalidatePath(`/stocks/${transaction.stockId}`); revalidatePath("/dashboard"); return { success: true }; } catch (error) { console.error("Error deleting transaction:", error); return { success: false, error: "Failed to delete transaction" }; } } /** * Export transactions to CSV */ export async function exportTransactionsToCSV() { try { const user = await getCurrentUser(); const transactions = await prisma.transaction.findMany({ where: { userId: user.id }, include: { stock: { select: { ticker: true, name: true, }, }, notes: { select: { content: true, }, }, }, orderBy: { date: "desc" }, }); // Format data for CSV export const exportData = transactions.map((transaction) => ({ Date: transaction.date, Ticker: transaction.stock.ticker, Company: transaction.stock.name, Type: transaction.type, Quantity: transaction.quantity, Price: transaction.price, Currency: transaction.currency, ExchangeRate: transaction.exchangeRate || 1, FXFee: transaction.fxFee || 0, Total: (transaction.price * transaction.quantity * (transaction.exchangeRate || 1)) + (transaction.type === 'BUY' ? (transaction.fxFee || 0) : -(transaction.fxFee || 0)), Notes: transaction.notes.map(note => note.content).join(" | "), })); return { success: true, data: exportData }; } catch (error) { console.error("Error exporting transactions:", error); return { success: false, error: "Failed to export transactions" }; } }
```

# src/actions/stocks.ts

```ts
"use server"; import { prisma } from "@/lib/db"; import { StockFormValues, StockWithNoteFormValues } from "@/lib/validators"; import { createAuditLog } from "@/lib/utils"; import { getCurrentUser } from "./user"; import { revalidatePath } from "next/cache"; import { createNote } from "./notes"; /** * Get all stocks for the current user */ export async function getStocks() { try { const user = await getCurrentUser(); const stocks = await prisma.stock.findMany({ where: { userId: user.id }, include: { sector: true, transactions: true, notes: { select: { id: true, content: true, createdAt: true, }, orderBy: { createdAt: "desc", }, }, }, orderBy: { createdAt: "desc" }, }); return { success: true, data: stocks }; } catch (error) { console.error("Error getting stocks:", error); return { success: false, error: "Failed to fetch stocks" }; } } /** * Get a stock by ID */ export async function getStockById(id: string) { try { const user = await getCurrentUser(); const stock = await prisma.stock.findFirst({ where: { id, userId: user.id, }, include: { sector: true, transactions: { orderBy: { date: "desc" }, }, notes: { select: { id: true, content: true, createdAt: true, }, orderBy: { createdAt: "desc" }, }, }, }); if (!stock) { return { success: false, error: "Stock not found" }; } return { success: true, data: stock }; } catch (error) { console.error("Error getting stock:", error); return { success: false, error: "Failed to fetch stock" }; } } /** * Create a new stock */ export async function createStock(data: StockFormValues) { try { const user = await getCurrentUser(); // Check if stock with same ticker already exists for this user const existingStock = await prisma.stock.findFirst({ where: { ticker: data.ticker.toUpperCase(), userId: user.id, }, }); if (existingStock) { return { success: false, error: "You already have a stock with this ticker" }; } // Handle "none" value for sectorId const sectorId = data.sectorId === "none" ? null : data.sectorId; // Create the stock with currency const stock = await prisma.stock.create({ data: { ticker: data.ticker.toUpperCase(), name: data.name, sectorId: sectorId || null, userId: user.id, currency: data.currency || "USD", // Default to USD if not provided }, }); // Create audit log await createAuditLog(prisma, { action: "CREATE_STOCK", entityType: "Stock", entityId: stock.id, userId: user.id, payload: { ticker: stock.ticker, name: stock.name, currency: stock.currency, }, }); revalidatePath("/stocks"); return { success: true, data: stock }; } catch (error) { console.error("Error creating stock:", error); return { success: false, error: "Failed to create stock" }; } } /** * Update a stock */ export async function updateStock(id: string, data: StockFormValues) { try { const user = await getCurrentUser(); // Check if stock exists and belongs to user const stock = await prisma.stock.findFirst({ where: { id, userId: user.id, }, }); if (!stock) { return { success: false, error: "Stock not found" }; } // Check if updated ticker already exists for another stock if (data.ticker.toUpperCase() !== stock.ticker) { const existingStock = await prisma.stock.findFirst({ where: { ticker: data.ticker.toUpperCase(), userId: user.id, id: { not: id }, }, }); if (existingStock) { return { success: false, error: "You already have a stock with this ticker" }; } } // Handle "none" value for sectorId const sectorId = data.sectorId === "none" ? null : data.sectorId; // Update the stock const updatedStock = await prisma.stock.update({ where: { id }, data: { ticker: data.ticker.toUpperCase(), name: data.name, sectorId: sectorId || null, currency: data.currency || stock.currency, // Keep existing currency if not provided }, }); // Create audit log await createAuditLog(prisma, { action: "UPDATE_STOCK", entityType: "Stock", entityId: updatedStock.id, userId: user.id, payload: { ticker: updatedStock.ticker, name: updatedStock.name, currency: updatedStock.currency, }, }); revalidatePath("/stocks"); revalidatePath(`/stocks/${id}`); return { success: true, data: updatedStock }; } catch (error) { console.error("Error updating stock:", error); return { success: false, error: "Failed to update stock" }; } } /** * Delete a stock */ export async function deleteStock(id: string) { try { const user = await getCurrentUser(); // Check if stock exists and belongs to user const stock = await prisma.stock.findFirst({ where: { id, userId: user.id, }, include: { transactions: true, notes: true, }, }); if (!stock) { return { success: false, error: "Stock not found" }; } // Check if stock has transactions if (stock.transactions.length > 0) { return { success: false, error: "Cannot delete a stock with transactions. Delete the transactions first." }; } // Delete related notes if (stock.notes.length > 0) { await prisma.note.deleteMany({ where: { stockId: id, }, }); } // Delete the stock await prisma.stock.delete({ where: { id }, }); // Create audit log await createAuditLog(prisma, { action: "DELETE_STOCK", entityType: "Stock", entityId: id, userId: user.id, payload: { ticker: stock.ticker, currency: stock.currency, }, }); revalidatePath("/stocks"); return { success: true }; } catch (error) { console.error("Error deleting stock:", error); return { success: false, error: "Failed to delete stock" }; } } /** * Get all sectors */ export async function getSectors() { try { const sectors = await prisma.sector.findMany({ orderBy: { name: "asc" }, }); return { success: true, data: sectors }; } catch (error) { console.error("Error getting sectors:", error); return { success: false, error: "Failed to fetch sectors" }; } }
```

# src/actions/notes.ts

```ts
"use server"; import { prisma } from "@/lib/db"; import { NoteFormValues } from "@/lib/validators"; import { createAuditLog } from "@/lib/utils"; import { getCurrentUser } from "./user"; import { revalidatePath } from "next/cache"; /** * Get all notes for a specific stock */ export async function getNotesByStockId(stockId: string) { try { const user = await getCurrentUser(); const notes = await prisma.note.findMany({ where: { stockId: stockId, userId: user.id, }, orderBy: { createdAt: "desc" }, }); return { success: true, data: notes }; } catch (error) { console.error(`Error getting notes for stock ID ${stockId}:`, error); return { success: false, error: "Failed to fetch notes for this stock" }; } } /** * Get all notes for the current user */ export async function getNotes() { try { const user = await getCurrentUser(); const notes = await prisma.note.findMany({ where: { userId: user.id }, include: { stock: true, transaction: { include: { stock: true, }, }, }, orderBy: { createdAt: "desc" }, }); return { success: true, data: notes }; } catch (error) { console.error("Error getting notes:", error); return { success: false, error: "Failed to fetch notes" }; } } /** * Get a note by ID */ export async function getNoteById(id: string) { try { const user = await getCurrentUser(); const note = await prisma.note.findFirst({ where: { id, userId: user.id, }, include: { stock: true, transaction: { include: { stock: true, }, }, }, }); if (!note) { return { success: false, error: "Note not found" }; } return { success: true, data: note }; } catch (error) { console.error("Error getting note:", error); return { success: false, error: "Failed to fetch note" }; } } /** * Create a new note */ export async function createNote(data: NoteFormValues) { try { const user = await getCurrentUser(); // Validate if stock exists if stockId is provided if (data.stockId) { const stock = await prisma.stock.findFirst({ where: { id: data.stockId, userId: user.id, }, }); if (!stock) { return { success: false, error: "Stock not found" }; } } // Validate if transaction exists if transactionId is provided if (data.transactionId) { const transaction = await prisma.transaction.findFirst({ where: { id: data.transactionId, userId: user.id, }, }); if (!transaction) { return { success: false, error: "Transaction not found" }; } } // Create the note const note = await prisma.note.create({ data: { content: data.content, stockId: data.stockId || null, transactionId: data.transactionId || null, userId: user.id, }, include: { stock: true, transaction: true, }, }); // Create audit log await createAuditLog(prisma, { action: "CREATE_NOTE", entityType: "Note", entityId: note.id, userId: user.id, payload: { stockTicker: note.stock?.ticker, transactionId: note.transaction?.id, }, }); revalidatePath("/notes"); if (data.stockId) { revalidatePath(`/stocks/${data.stockId}`); revalidatePath("/stocks"); } if (data.transactionId) { revalidatePath(`/transactions/${data.transactionId}`); revalidatePath("/transactions"); } return { success: true, data: note }; } catch (error) { console.error("Error creating note:", error); return { success: false, error: "Failed to create note" }; } } /** * Update a note */ export async function updateNote(id: string, data: NoteFormValues) { try { const user = await getCurrentUser(); // Check if note exists and belongs to user const note = await prisma.note.findFirst({ where: { id, userId: user.id, }, }); if (!note) { return { success: false, error: "Note not found" }; } // Validate if stock exists if stockId is provided if (data.stockId) { const stock = await prisma.stock.findFirst({ where: { id: data.stockId, userId: user.id, }, }); if (!stock) { return { success: false, error: "Stock not found" }; } } // Validate if transaction exists if transactionId is provided if (data.transactionId) { const transaction = await prisma.transaction.findFirst({ where: { id: data.transactionId, userId: user.id, }, }); if (!transaction) { return { success: false, error: "Transaction not found" }; } } // Update the note const updatedNote = await prisma.note.update({ where: { id }, data: { content: data.content, stockId: data.stockId || null, transactionId: data.transactionId || null, }, include: { stock: true, transaction: true, }, }); // Create audit log await createAuditLog(prisma, { action: "UPDATE_NOTE", entityType: "Note", entityId: updatedNote.id, userId: user.id, payload: { stockTicker: updatedNote.stock?.ticker, transactionId: updatedNote.transaction?.id, }, }); revalidatePath("/notes"); revalidatePath(`/notes/${id}`); if (note.stockId) { revalidatePath(`/stocks/${note.stockId}`); revalidatePath("/stocks"); } if (data.stockId && note.stockId !== data.stockId) { revalidatePath(`/stocks/${data.stockId}`); revalidatePath("/stocks"); } if (note.transactionId) { revalidatePath(`/transactions/${note.transactionId}`); revalidatePath("/transactions"); } if (data.transactionId && note.transactionId !== data.transactionId) { revalidatePath(`/transactions/${data.transactionId}`); revalidatePath("/transactions"); } return { success: true, data: updatedNote }; } catch (error) { console.error("Error updating note:", error); return { success: false, error: "Failed to update note" }; } } /** * Delete a note */ export async function deleteNote(id: string) { try { const user = await getCurrentUser(); // Check if note exists and belongs to user const note = await prisma.note.findFirst({ where: { id, userId: user.id, }, }); if (!note) { return { success: false, error: "Note not found" }; } // Store references to linked items for path revalidation const stockId = note.stockId; const transactionId = note.transactionId; // Delete the note await prisma.note.delete({ where: { id }, }); // Create audit log await createAuditLog(prisma, { action: "DELETE_NOTE", entityType: "Note", entityId: id, userId: user.id, }); revalidatePath("/notes"); if (stockId) { revalidatePath(`/stocks/${stockId}`); revalidatePath("/stocks"); } if (transactionId) { revalidatePath(`/transactions/${transactionId}`); revalidatePath("/transactions"); } return { success: true }; } catch (error) { console.error("Error deleting note:", error); return { success: false, error: "Failed to delete note" }; } }
```

# src/actions/auth.ts

```ts

```

# prisma/migrations/migration_lock.toml

```toml
# Please do not edit this file manually # It should be added in your version-control system (i.e. Git) provider = "sqlite"
```

# src/app/transactions/page.tsx

```tsx
/* ------------------------------------------------------------- src/app/transactions/page.tsx -------------------------------------------------------------- */ import { Metadata } from "next"; import { getTransactions } from "@/actions/transactions"; import { getStocks } from "@/actions/stocks"; import TransactionsHeader from "@/components/transactions/transactions-header"; import TransactionsTable from "@/components/transactions/transactions-table"; import { Currency } from "@/lib/validators"; export const metadata: Metadata = { title: "Transactions | Stock Manager", description: "View and manage your stock transactions", }; export default async function TransactionsPage() { /* ---------- fetch ---------- */ const [txRes, stockRes] = await Promise.all([ getTransactions(), getStocks(), ]); const rawTx = txRes.success ? txRes.data ?? [] : []; const rawStocks = stockRes.success ? stockRes.data ?? [] : []; /* ---------- cast currency fields ---------- */ const transactions = rawTx.map((tx) => ({ ...tx, currency: (tx.currency || tx.stock.currency || "USD") as Currency, stock: { ...tx.stock, currency: (tx.stock.currency || "USD") as Currency, }, })); const typedStocks = rawStocks.map((s) => ({ ...s, currency: (s.currency || "USD") as Currency, })); /* ---------- render ---------- */ return ( <div className="space-y-6"> <TransactionsHeader /> <TransactionsTable transactions={transactions} stocks={typedStocks} /> </div> ); }
```

# src/app/dashboard/page.tsx

```tsx
// ----------------------------------------------------------------------------- // src/app/dashboard/page.tsx (complete replacement file) // ----------------------------------------------------------------------------- import { Metadata } from "next"; import { getCurrentUser } from "@/actions/user"; import { getStocks } from "@/actions/stocks"; import { getTransactions } from "@/actions/transactions"; import { calculateAveragePrice, calculateTotalHoldings, } from "@/lib/utils"; import DashboardHeader from "@/components/dashboard/dashboard-header"; import PortfolioValue from "@/components/dashboard/portfolio-value"; import StockSummary from "@/components/dashboard/stock-summary"; import SectorBreakdown from "@/components/dashboard/sector-breakdown"; import RecentTransactions from "@/components/dashboard/recent-transactions"; import { Currency } from "@/lib/validators"; export const metadata: Metadata = { title: "Dashboard | Stock Manager", description: "View your stock portfolio at a glance", }; export default async function DashboardPage() { /* ----------------------------------------------------------------------- */ /* 1. Fetch data */ /* ----------------------------------------------------------------------- */ const [user, stocksRes, txRes] = await Promise.all([ getCurrentUser(), getStocks(), getTransactions(), ]); const rawStocks = stocksRes.success ? stocksRes.data ?? [] : []; const rawTx = txRes.success ? txRes.data ?? [] : []; const userCurrency = (user.defaultCurrency || "GBP") as Currency; /* ----------------------------------------------------------------------- */ /* 2. Cast currency literals & compute per‑stock metrics */ /* ----------------------------------------------------------------------- */ const transactions = rawTx.map((t) => ({ ...t, currency: (t.currency || t.stock.currency || "USD") as Currency, stock: { ...t.stock, currency: (t.stock.currency || "USD") as Currency }, })); const stocks = rawStocks.map((s) => ({ ...s, currency: (s.currency || "USD") as Currency, })); const stocksWithMetrics = stocks.map((s) => { const txForStock = transactions.filter((t) => t.stockId === s.id); const averagePrice = calculateAveragePrice(txForStock); const holdings = calculateTotalHoldings(txForStock); const value = holdings * averagePrice; return { ...s, averagePrice, holdings, value }; }); /* ----------------------------------------------------------------------- */ /* 3. Aggregate portfolio & sector data */ /* ----------------------------------------------------------------------- */ const portfolioValue = stocksWithMetrics.reduce( (sum, s) => sum + s.value, 0, ); const sectorMap = stocksWithMetrics.reduce<Record<string, number>>( (acc, s) => { if (s.holdings === 0) return acc; const name = s.sector?.name || "Uncategorised"; acc[name] = (acc[name] || 0) + s.value; return acc; }, {}, ); const sectorBreakdown = Object.entries(sectorMap).map(([name, value]) => ({ name, value, percentage: portfolioValue ? (value / portfolioValue) * 100 : 0, })); /* five most‑recent transactions */ const recentTransactions = [...transactions] .sort((a, b) => b.date.getTime() - a.date.getTime()) .slice(0, 5); /* ----------------------------------------------------------------------- */ /* 4. Render */ /* ----------------------------------------------------------------------- */ return ( <div className="space-y-6"> <DashboardHeader username={user.name} portfolioValue={portfolioValue} currency={userCurrency} /> <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3"> <PortfolioValue portfolioValue={portfolioValue} stocksCount={stocksWithMetrics.length} currency={userCurrency} /> <SectorBreakdown sectors={sectorBreakdown} currency={userCurrency} /> <RecentTransactions transactions={recentTransactions} /* this component doesn’t yet need baseCurrency */ /> </div> <StockSummary stocks={stocksWithMetrics} /> </div> ); }
```

# src/app/stocks/page.tsx

```tsx
// ----------------------------------------------------------------------------- // src/app/stocks/page.tsx (complete replacement file) // ----------------------------------------------------------------------------- import { Metadata } from "next"; import { getStocks, getSectors } from "@/actions/stocks"; import { getTransactions } from "@/actions/transactions"; import StocksHeader from "@/components/stocks/stocks-header"; import StocksTable, { Stock as StocksTableStockType, } from "@/components/stocks/stocks-table"; import { calculateAveragePrice, calculateTotalHoldings, } from "@/lib/utils"; import { Currency } from "@/lib/validators"; export const metadata: Metadata = { title: "Stocks | Stock Manager", description: "Manage your stock portfolio", }; /** * Collapse duplicate Stock rows that share the same (userId, ticker). * We keep static fields from the earliest created record and merge * transactions / notes from all duplicates so the UI shows a single, * aggregated position. */ export default async function StocksPage() { const [stocksRes, txRes, sectorsRes] = await Promise.all([ getStocks(), getTransactions(), getSectors(), ]); const rawStocks = stocksRes.success ? stocksRes.data ?? [] : []; const transactions = txRes.success ? txRes.data ?? [] : []; const sectors = sectorsRes.success ? sectorsRes.data ?? [] : []; // --------------------------------------------------------------------------- // 1. Group duplicate stock records by ticker // --------------------------------------------------------------------------- const groups = new Map< string, // ticker { base: typeof rawStocks[number]; // first record encountered txs: typeof transactions; // combined transactions notes: typeof rawStocks[number]["notes"]; // combined notes } >(); for (const s of rawStocks) { const entry = groups.get(s.ticker); if (entry) { entry.txs.push( ...transactions.filter((t) => t.stockId === s.id), ); entry.notes.push(...(s.notes || [])); } else { groups.set(s.ticker, { base: s, txs: transactions.filter((t) => t.stockId === s.id), notes: s.notes || [], }); } } // --------------------------------------------------------------------------- // 2. Build the array expected by <StocksTable> // --------------------------------------------------------------------------- const enhancedStocks: StocksTableStockType[] = Array.from( groups.values(), ).map(({ base, txs, notes }) => { const averagePrice = calculateAveragePrice(txs); const holdings = calculateTotalHoldings(txs); const value = holdings * averagePrice; return { id: base.id, // first record’s id (only used for URL) ticker: base.ticker, name: base.name, sectorId: base.sectorId, sector: base.sector, averagePrice, holdings, value, transactions: txs.length, notes, currency: (base.currency || "USD") as Currency, }; }); // --------------------------------------------------------------------------- // 3. Render // --------------------------------------------------------------------------- return ( <div className="space-y-6"> <StocksHeader /> <StocksTable stocks={enhancedStocks} sectors={sectors} /> </div> ); }
```

# src/app/settings/page.tsx

```tsx
// src/app/settings/page.tsx import { Metadata } from "next"; import { getCurrentUser } from "@/actions/user"; import { getSectors } from "@/actions/stocks"; import UserProfileForm from "@/components/settings/user-profile-form"; import AppearanceSettings from "@/components/settings/appearance-settings"; import DataManagementSettings from "@/components/settings/data-management-settings"; import SectorsManagement from "@/components/settings/sectors-management"; import { Currency } from "@/lib/validators"; // Import the Currency type export const metadata: Metadata = { title: "Settings | Stock Manager", description: "Configure your stock portfolio manager", }; export default async function SettingsPage() { const [user, sectorsResponse] = await Promise.all([ getCurrentUser(), getSectors(), ]); const sectors = sectorsResponse.success ? sectorsResponse.data ?? [] : []; // Cast the user object to ensure defaultCurrency matches the expected type const typedUser = { ...user, defaultCurrency: (user.defaultCurrency || "GBP") as Currency, // Cast here }; return ( <div className="space-y-6"> <div> <h2 className="text-2xl font-bold tracking-tight">Settings</h2> <p className="text-muted-foreground"> Configure your preferences and account settings </p> </div> <div className="grid gap-6"> {/* Pass the correctly typed user object */} <UserProfileForm user={typedUser} /> <AppearanceSettings /> <SectorsManagement sectors={sectors} /> <DataManagementSettings /> </div> </div> ); }
```

# src/app/notes/page.tsx

```tsx
import { Metadata } from "next"; import { getNotes } from "@/actions/notes"; import NotesHeader from "@/components/notes/notes-header"; import NotesTable from "@/components/notes/notes-table"; export const metadata: Metadata = { title: "Notes | Stock Manager", description: "Manage your stock notes and research", }; export default async function NotesPage() { const { success, data: notes, error } = await getNotes(); return ( <div className="space-y-6"> <NotesHeader /> <NotesTable notes={success ? notes ?? [] : []} /> </div> ); }
```

# src/components/settings/user-profile-form.tsx

```tsx
"use client"; import { useState } from "react"; import { useForm } from "react-hook-form"; import { zodResolver } from "@hookform/resolvers/zod"; import { UserProfileFormValues, userProfileSchema } from "@/lib/validators"; import { updateUserProfile } from "@/actions/user"; import { useToast } from "@/hooks/use-toast"; import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle, } from "@/components/ui/card"; import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage, } from "@/components/ui/form"; import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue, } from "@/components/ui/select"; import { Input } from "@/components/ui/input"; import { Button } from "@/components/ui/button"; import { getCurrencySymbol } from "@/lib/utils"; import { Currency } from "@/lib/validators"; interface User { id: string; name: string; email: string; defaultCurrency: Currency; } interface UserProfileFormProps { user: User; } export default function UserProfileForm({ user }: UserProfileFormProps) { const { toast } = useToast(); const [isLoading, setIsLoading] = useState(false); const form = useForm<UserProfileFormValues>({ resolver: zodResolver(userProfileSchema), defaultValues: { name: user.name, email: user.email, defaultCurrency: (user.defaultCurrency || "GBP") as Currency, }, }); const onSubmit = async (data: UserProfileFormValues) => { setIsLoading(true); try { const result = await updateUserProfile(data); if (result.success) { toast({ title: "Profile updated", description: "Your profile has been updated successfully.", }); } else { toast({ title: "Error", description: result.error || "Failed to update profile.", variant: "destructive", }); } } catch (error) { toast({ title: "Error", description: "An unexpected error occurred.", variant: "destructive", }); } finally { setIsLoading(false); } }; return ( <Card> <CardHeader> <CardTitle>Profile</CardTitle> <CardDescription>Manage your personal information</CardDescription> </CardHeader> <Form {...form}> <form onSubmit={form.handleSubmit(onSubmit)}> <CardContent className="space-y-4"> <FormField control={form.control} name="name" render={({ field }) => ( <FormItem> <FormLabel>Name</FormLabel> <FormControl> <Input placeholder="Your name" {...field} /> </FormControl> <FormMessage /> </FormItem> )} /> <FormField control={form.control} name="email" render={({ field }) => ( <FormItem> <FormLabel>Email</FormLabel> <FormControl> <Input placeholder="Your email" {...field} /> </FormControl> <FormMessage /> </FormItem> )} /> <FormField control={form.control} name="defaultCurrency" render={({ field }) => ( <FormItem> <FormLabel>Default Currency</FormLabel> <Select onValueChange={field.onChange as (value: string) => void} defaultValue={field.value} > <FormControl> <SelectTrigger> <SelectValue placeholder="Select a currency" /> </SelectTrigger> </FormControl> <SelectContent> <SelectItem value="GBP">{getCurrencySymbol("GBP")} GBP - British Pound</SelectItem> <SelectItem value="USD">{getCurrencySymbol("USD")} USD - US Dollar</SelectItem> <SelectItem value="EUR">{getCurrencySymbol("EUR")} EUR - Euro</SelectItem> <SelectItem value="JPY">{getCurrencySymbol("JPY")} JPY - Japanese Yen</SelectItem> <SelectItem value="CHF">{getCurrencySymbol("CHF")} CHF - Swiss Franc</SelectItem> <SelectItem value="CAD">{getCurrencySymbol("CAD")} CAD - Canadian Dollar</SelectItem> <SelectItem value="AUD">{getCurrencySymbol("AUD")} AUD - Australian Dollar</SelectItem> </SelectContent> </Select> <FormMessage /> </FormItem> )} /> </CardContent> <CardFooter> <Button type="submit" disabled={isLoading}> {isLoading ? "Saving..." : "Save Changes"} </Button> </CardFooter> </form> </Form> </Card> ); }
```

# src/components/settings/sectors-management.tsx

```tsx
"use client"; import { useState } from "react"; import { Card, CardContent, CardDescription, CardHeader, CardTitle, } from "@/components/ui/card"; import { Button } from "@/components/ui/button"; import { TagIcon, PlusIcon } from "lucide-react"; interface Sector { id: string; name: string; } interface SectorsManagementProps { sectors: Sector[]; } export default function SectorsManagement({ sectors }: SectorsManagementProps) { return ( <Card> <CardHeader> <CardTitle>Sectors</CardTitle> <CardDescription> Manage industry sectors for your stocks </CardDescription> </CardHeader> <CardContent className="space-y-4"> <div className="flex flex-wrap gap-2"> {sectors.map((sector) => ( <div key={sector.id} className="flex items-center bg-secondary text-secondary-foreground rounded-md px-3 py-1 text-sm" > <TagIcon className="mr-1 h-3 w-3" /> {sector.name} </div> ))} </div> <p className="text-xs text-muted-foreground"> Industry sectors are pre-configured and cannot be edited directly. They are automatically used when adding or editing stocks. </p> </CardContent> </Card> ); }
```

# src/components/settings/data-management-settings.tsx

```tsx
"use client"; import { useState } from "react"; import { exportTransactionsToCSV } from "@/actions/transactions"; import { useToast } from "@/hooks/use-toast"; import { Card, CardContent, CardDescription, CardHeader, CardTitle, CardFooter, } from "@/components/ui/card"; import { Button } from "@/components/ui/button"; import { DownloadIcon } from "lucide-react"; import { exportToCSV } from "@/lib/utils"; export default function DataManagementSettings() { const { toast } = useToast(); const [isExporting, setIsExporting] = useState(false); const handleExport = async () => { setIsExporting(true); try { const result = await exportTransactionsToCSV(); if (result.success && result.data) { // Export the data to CSV const filename = `stock_transactions_${new Date().toISOString().split('T')[0]}.csv`; exportToCSV(result.data, filename); toast({ title: "Export successful", description: "Your transactions have been exported to CSV.", }); } else { toast({ title: "Export failed", description: result.error || "Failed to export transactions.", variant: "destructive", }); } } catch (error) { toast({ title: "Export failed", description: "An unexpected error occurred.", variant: "destructive", }); } finally { setIsExporting(false); } }; return ( <Card> <CardHeader> <CardTitle>Data Management</CardTitle> <CardDescription> Export and manage your portfolio data </CardDescription> </CardHeader> <CardContent className="space-y-4"> <div> <h3 className="text-sm font-medium">Export Data</h3> <p className="text-sm text-muted-foreground mt-1"> Download your transaction history as a CSV file </p> </div> </CardContent> <CardFooter> <Button onClick={handleExport} disabled={isExporting} className="w-full sm:w-auto" > <DownloadIcon className="mr-2 h-4 w-4" /> {isExporting ? "Exporting..." : "Export Transactions"} </Button> </CardFooter> </Card> ); }
```

# src/components/settings/appearance-settings.tsx

```tsx
"use client"; import { useTheme } from "next-themes"; import { Card, CardContent, CardDescription, CardHeader, CardTitle, } from "@/components/ui/card"; import { Label } from "@/components/ui/label"; import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue, } from "@/components/ui/select"; import { Button } from "@/components/ui/button"; import { MoonIcon, SunIcon, MonitorIcon } from "lucide-react"; export default function AppearanceSettings() { const { theme, setTheme } = useTheme(); return ( <Card> <CardHeader> <CardTitle>Appearance</CardTitle> <CardDescription> Customize how the application looks </CardDescription> </CardHeader> <CardContent className="space-y-6"> <div className="space-y-2"> <Label>Theme</Label> <div className="grid grid-cols-3 gap-2"> <Button variant={theme === "light" ? "default" : "outline"} className="justify-start" onClick={() => setTheme("light")} > <SunIcon className="mr-2 h-4 w-4" /> Light </Button> <Button variant={theme === "dark" ? "default" : "outline"} className="justify-start" onClick={() => setTheme("dark")} > <MoonIcon className="mr-2 h-4 w-4" /> Dark </Button> <Button variant={theme === "system" ? "default" : "outline"} className="justify-start" onClick={() => setTheme("system")} > <MonitorIcon className="mr-2 h-4 w-4" /> System </Button> </div> <p className="text-xs text-muted-foreground mt-2"> Choose a theme for the application. System setting will follow your device preferences. </p> </div> </CardContent> </Card> ); }
```

# src/components/transactions/transactions-table.tsx

```tsx
"use client"; import { useState, useEffect } from "react"; import Link from "next/link"; import { Card, CardContent } from "@/components/ui/card"; import { Input } from "@/components/ui/input"; import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue, } from "@/components/ui/select"; import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger, } from "@/components/ui/dropdown-menu"; import { Button } from "@/components/ui/button"; import { MoreHorizontalIcon, PencilIcon, TrashIcon, ArrowUpIcon, ArrowDownIcon, FileTextIcon, CurrencyIcon, } from "lucide-react"; import { formatCurrency, formatDate, calculateTransactionTotal, getCurrencySymbol } from "@/lib/utils"; import { TransactionType } from "@/lib/constants"; import EditTransactionForm from "@/components/transactions/edit-transaction-form"; import DeleteTransactionDialog from "@/components/transactions/delete-transaction-dialog"; import { getCurrentUser } from "@/actions/user"; interface Transaction { id: string; type: string; quantity: number; price: number; currency: string; exchangeRate?: number | null; fxFee?: number | null; date: Date; stock: { id: string; ticker: string; name: string; currency: string; sector?: { id: string; name: string; } | null; }; notes?: { id: string; content: string; }[]; } interface Stock { id: string; ticker: string; name: string; currency: string; sector?: { id: string; name: string; } | null; } interface TransactionsTableProps { transactions: Transaction[]; stocks: Stock[]; } export default function TransactionsTable({ transactions, stocks }: TransactionsTableProps) { const [search, setSearch] = useState(""); const [stockFilter, setStockFilter] = useState("all"); const [typeFilter, setTypeFilter] = useState("all"); const [currencyFilter, setCurrencyFilter] = useState("all"); const [sortBy, setSortBy] = useState<keyof Transaction | "stock" | "total">("date"); const [sortDirection, setSortDirection] = useState<"asc" | "desc">("desc"); const [transactionToEdit, setTransactionToEdit] = useState<Transaction | null>(null); const [transactionToDelete, setTransactionToDelete] = useState<Transaction | null>(null); const [userDefaultCurrency, setUserDefaultCurrency] = useState<string>("GBP"); const [uniqueCurrencies, setUniqueCurrencies] = useState<string[]>([]); // Get user's default currency useEffect(() => { const fetchUserCurrency = async () => { try { const user = await getCurrentUser(); setUserDefaultCurrency(user.defaultCurrency || "GBP"); } catch (error) { console.error("Error fetching user currency:", error); } }; fetchUserCurrency(); }, []); // Get unique currencies in transactions useEffect(() => { const currencies = new Set<string>(); transactions.forEach(t => { currencies.add(t.currency || t.stock.currency || "USD"); }); setUniqueCurrencies(Array.from(currencies)); }, [transactions]); // Apply filters let filteredTransactions = [...transactions]; // Apply search filter if (search) { const searchLower = search.toLowerCase(); filteredTransactions = filteredTransactions.filter( (transaction) => transaction.stock.ticker.toLowerCase().includes(searchLower) || transaction.stock.name.toLowerCase().includes(searchLower) ); } // Apply stock filter if (stockFilter !== "all") { filteredTransactions = filteredTransactions.filter( (transaction) => transaction.stock.id === stockFilter ); } // Apply type filter if (typeFilter !== "all") { filteredTransactions = filteredTransactions.filter( (transaction) => transaction.type === typeFilter ); } // Apply currency filter if (currencyFilter !== "all") { filteredTransactions = filteredTransactions.filter( (transaction) => { return (transaction.currency || transaction.stock.currency) === currencyFilter; } ); } // Add total to transactions for sorting const transactionsWithTotal = filteredTransactions.map(transaction => ({ ...transaction, total: calculateTransactionTotal(transaction), })); // Apply sorting transactionsWithTotal.sort((a, b) => { if (sortBy === "stock") { const tickerA = a.stock.ticker; const tickerB = b.stock.ticker; return sortDirection === "asc" ? tickerA.localeCompare(tickerB) : tickerB.localeCompare(tickerA); } if (sortBy === "date") { const dateA = new Date(a.date).getTime(); const dateB = new Date(b.date).getTime(); return sortDirection === "asc" ? dateA - dateB : dateB - dateA; } if (sortBy === "total") { return sortDirection === "asc" ? a.total - b.total : b.total - a.total; } const valueA = a[sortBy]; const valueB = b[sortBy]; if (typeof valueA === "string" && typeof valueB === "string") { return sortDirection === "asc" ? valueA.localeCompare(valueB) : valueB.localeCompare(valueA); } if (typeof valueA === "number" && typeof valueB === "number") { return sortDirection === "asc" ? valueA - valueB : valueB - valueA; } return 0; }); // Toggle sort direction when clicking on the same column const handleSort = (column: keyof Transaction | "stock" | "total") => { if (sortBy === column) { setSortDirection(sortDirection === "asc" ? "desc" : "asc"); } else { setSortBy(column); setSortDirection("desc"); } }; return ( <div> <div className="flex flex-col sm:flex-row gap-4 mb-4"> <Input placeholder="Search transactions..." value={search} onChange={(e) => setSearch(e.target.value)} className="sm:max-w-xs" /> <Select value={stockFilter} onValueChange={setStockFilter}> <SelectTrigger className="sm:max-w-xs"> <SelectValue placeholder="Filter by stock" /> </SelectTrigger> <SelectContent> <SelectItem value="all">All Stocks</SelectItem> {stocks.map((stock) => ( <SelectItem key={stock.id} value={stock.id}> {stock.ticker}: {stock.name} ({getCurrencySymbol(stock.currency)}) </SelectItem> ))} </SelectContent> </Select> <Select value={typeFilter} onValueChange={setTypeFilter}> <SelectTrigger className="sm:max-w-xs"> <SelectValue placeholder="Filter by type" /> </SelectTrigger> <SelectContent> <SelectItem value="all">All Types</SelectItem> <SelectItem value={TransactionType.BUY}>Buy</SelectItem> <SelectItem value={TransactionType.SELL}>Sell</SelectItem> </SelectContent> </Select> <Select value={currencyFilter} onValueChange={setCurrencyFilter}> <SelectTrigger className="sm:max-w-xs"> <SelectValue placeholder="Filter by currency" /> </SelectTrigger> <SelectContent> <SelectItem value="all">All Currencies</SelectItem> {uniqueCurrencies.map((currency) => ( <SelectItem key={currency} value={currency}> {getCurrencySymbol(currency)} {currency} </SelectItem> ))} </SelectContent> </Select> </div> <Card> <CardContent className="p-0"> <div className="overflow-x-auto"> <table className="w-full text-sm"> <thead> <tr className="border-b"> <th className="text-left font-medium py-4 px-6 cursor-pointer hover:bg-muted/50" onClick={() => handleSort("date")} > Date {sortBy === "date" && ( <span className="ml-1"> {sortDirection === "asc" ? "↑" : "↓"} </span> )} </th> <th className="text-left font-medium py-4 px-6 cursor-pointer hover:bg-muted/50" onClick={() => handleSort("stock")} > Stock {sortBy === "stock" && ( <span className="ml-1"> {sortDirection === "asc" ? "↑" : "↓"} </span> )} </th> <th className="text-left font-medium py-4 px-6 cursor-pointer hover:bg-muted/50" onClick={() => handleSort("type")} > Type {sortBy === "type" && ( <span className="ml-1"> {sortDirection === "asc" ? "↑" : "↓"} </span> )} </th> <th className="text-right font-medium py-4 px-6 cursor-pointer hover:bg-muted/50" onClick={() => handleSort("quantity")} > Quantity {sortBy === "quantity" && ( <span className="ml-1"> {sortDirection === "asc" ? "↑" : "↓"} </span> )} </th> <th className="text-right font-medium py-4 px-6 cursor-pointer hover:bg-muted/50" onClick={() => handleSort("price")} > Price {sortBy === "price" && ( <span className="ml-1"> {sortDirection === "asc" ? "↑" : "↓"} </span> )} </th> <th className="text-center font-medium py-4 px-3 cursor-pointer hover:bg-muted/50" onClick={() => handleSort("currency")} > Currency {sortBy === "currency" && ( <span className="ml-1"> {sortDirection === "asc" ? "↑" : "↓"} </span> )} </th> <th className="text-right font-medium py-4 px-6 cursor-pointer hover:bg-muted/50" onClick={() => handleSort("total")} > Total {sortBy === "total" && ( <span className="ml-1"> {sortDirection === "asc" ? "↑" : "↓"} </span> )} </th> <th className="text-center font-medium py-4 px-6">Notes</th> <th className="text-right font-medium py-4 px-6"></th> </tr> </thead> <tbody className="divide-y"> {transactionsWithTotal.length === 0 ? ( <tr> <td colSpan={9} className="py-6 text-center text-muted-foreground"> {transactions.length === 0 ? "No transactions yet. Add your first transaction to get started." : "No transactions match your filters."} </td> </tr> ) : ( transactionsWithTotal.map((transaction) => { const isBuy = transaction.type === TransactionType.BUY; const transactionCurrency = transaction.currency || transaction.stock.currency || "USD"; const isForeignCurrency = transactionCurrency !== userDefaultCurrency; const currencySymbol = getCurrencySymbol(transactionCurrency); return ( <tr key={transaction.id} className="hover:bg-muted/50"> <td className="py-4 px-6"> {formatDate(transaction.date)} </td> <td className="py-4 px-6"> <Link href={`/stocks/${transaction.stock.id}`} className="font-medium hover:underline" > {transaction.stock.ticker} </Link> <div className="text-xs text-muted-foreground"> {transaction.stock.name} </div> </td> <td className="py-4 px-6"> <div className="flex items-center"> <div className={`mr-2 flex h-6 w-6 items-center justify-center rounded-full ${isBuy ? "bg-green-100 dark:bg-green-900" : "bg-red-100 dark:bg-red-900" }`} > {isBuy ? ( <ArrowDownIcon className="h-3 w-3 text-green-600 dark:text-green-400" /> ) : ( <ArrowUpIcon className="h-3 w-3 text-red-600 dark:text-red-400" /> )} </div> {isBuy ? "Buy" : "Sell"} </div> </td> <td className="py-4 px-6 text-right"> {transaction.quantity.toFixed(2)} </td> <td className="py-4 px-6 text-right"> {currencySymbol}{transaction.price.toFixed(2)} </td> <td className="py-4 px-3 text-center"> <div className="flex flex-col items-center"> <span className="text-xs font-medium"> {transactionCurrency} </span> {isForeignCurrency && ( <CurrencyIcon className="h-4 w-4 text-blue-600 dark:text-blue-400 mt-1" /> )} </div> </td> <td className="py-4 px-6 text-right font-medium"> {formatCurrency(transaction.total, userDefaultCurrency)} </td> <td className="py-4 px-6 text-center"> {transaction.notes && transaction.notes.length > 0 ? ( <div className="relative group inline-flex justify-center"> <div className="cursor-pointer hover:text-primary"> <FileTextIcon className="h-5 w-5" /> </div> <div className="invisible absolute z-10 w-64 -translate-x-1/2 -translate-y-8 rounded-md border bg-popover px-3 py-2 text-xs text-popover-foreground opacity-0 shadow-md transition-all group-hover:visible group-hover:opacity-100"> <div className="font-semibold mb-1">{transaction.notes.length} {transaction.notes.length === 1 ? 'note' : 'notes'}</div> <div className="line-clamp-2 text-muted-foreground"> {transaction.notes[0].content} </div> <div className="text-right mt-1"> <Link href={`/transactions/${transaction.id}`} className="text-primary text-xs hover:underline"> View all </Link> </div> </div> </div> ) : null} </td> <td className="py-4 px-6 text-right"> <DropdownMenu> <DropdownMenuTrigger asChild> <Button variant="ghost" size="sm"> <MoreHorizontalIcon className="h-4 w-4" /> <span className="sr-only">Actions</span> </Button> </DropdownMenuTrigger> <DropdownMenuContent align="end"> <DropdownMenuItem onClick={() => setTransactionToEdit(transaction)} className="cursor-pointer" > <PencilIcon className="mr-2 h-4 w-4" /> Edit </DropdownMenuItem> <DropdownMenuItem onClick={() => setTransactionToDelete(transaction)} className="cursor-pointer text-destructive focus:text-destructive" > <TrashIcon className="mr-2 h-4 w-4" /> Delete </DropdownMenuItem> </DropdownMenuContent> </DropdownMenu> </td> </tr> ); }) )} </tbody> </table> </div> </CardContent> </Card> {transactionToEdit && ( <EditTransactionForm transaction={transactionToEdit} stocks={stocks} open={!!transactionToEdit} onOpenChange={(open) => { if (!open) setTransactionToEdit(null); }} /> )} {transactionToDelete && ( <DeleteTransactionDialog transaction={transactionToDelete} open={!!transactionToDelete} onOpenChange={(open) => { if (!open) setTransactionToDelete(null); }} /> )} </div> ); }
```

# src/components/transactions/transactions-header.tsx

```tsx
"use client"; import { useState } from "react"; import { Button } from "@/components/ui/button"; import { PlusIcon } from "lucide-react"; import AddTransactionForm from "@/components/transactions/add-transaction-form"; export default function TransactionsHeader() { const [showAddForm, setShowAddForm] = useState(false); return ( <div className="flex flex-col gap-4 sm:flex-row sm:items-center sm:justify-between"> <div> <h2 className="text-2xl font-bold tracking-tight">Transactions</h2> <p className="text-muted-foreground"> View and manage your stock buy and sell transactions </p> </div> <Button onClick={() => setShowAddForm(true)} className="sm:w-auto w-full"> <PlusIcon className="mr-2 h-4 w-4" /> Add Transaction </Button> <AddTransactionForm open={showAddForm} onOpenChange={setShowAddForm} /> </div> ); }
```

# src/components/transactions/transactions-actions.tsx

```tsx
// path: src/components/transactions/transactions-actions.tsx "use client"; import { useState } from "react"; import { useRouter } from "next/navigation"; import { Button } from "@/components/ui/button"; import { PencilIcon, TrashIcon } from "lucide-react"; import EditTransactionForm, { EditFormTransaction, } from "@/components/transactions/edit-transaction-form"; import DeleteTransactionDialog from "@/components/transactions/delete-transaction-dialog"; import { Currency } from "@/lib/validators"; interface StockForEdit { id: string; ticker: string; name: string; currency: Currency; } interface TransactionsActionsProps { /** A fully‑typed transaction that already contains `currency` */ transaction: EditFormTransaction; } export default function TransactionsActions({ transaction, }: TransactionsActionsProps) { const router = useRouter(); const [showEditForm, setShowEditForm] = useState(false); const [showDeleteDialog, setShowDeleteDialog] = useState(false); const transactionForDelete = { id: transaction.id, type: transaction.type, quantity: transaction.quantity, stock: { ticker: transaction.stock.ticker, name: transaction.stock.name, }, }; const stocksForEdit: StockForEdit[] = [ { id: transaction.stock.id, ticker: transaction.stock.ticker, name: transaction.stock.name, currency: transaction.stock.currency, }, ]; return ( <div className="flex gap-2"> <Button variant="outline" size="sm" onClick={() => setShowEditForm(true)} > <PencilIcon className="mr-2 h-4 w-4" /> Edit </Button> <Button variant="outline" size="sm" className="text-destructive hover:text-destructive" onClick={() => setShowDeleteDialog(true)} > <TrashIcon className="mr-2 h-4 w-4" /> Delete </Button> {/* ---- edit ---- */} <EditTransactionForm transaction={transaction} stocks={stocksForEdit} open={showEditForm} onOpenChange={setShowEditForm} /> {/* ---- delete ---- */} <DeleteTransactionDialog transaction={transactionForDelete} open={showDeleteDialog} onOpenChange={(open) => { if (!open) { setShowDeleteDialog(false); } else if (!open && !transaction.id) { router.push("/transactions"); } }} /> </div> ); }
```

# src/components/transactions/transaction-notes.tsx

```tsx
"use client"; import { useState } from "react"; import { Card, CardContent, CardDescription, CardHeader, CardTitle, } from "@/components/ui/card"; import { Button } from "@/components/ui/button"; import { formatDate } from "@/lib/utils"; import { PlusIcon, PencilIcon, TrashIcon } from "lucide-react"; import AddNoteForm from "@/components/notes/add-note-form"; import EditNoteForm from "@/components/notes/edit-note-form"; import DeleteNoteDialog from "@/components/notes/delete-note-dialog"; interface Note { id: string; content: string; createdAt: Date; } interface TransactionNotesProps { transactionId: string; notes: Note[]; } export default function TransactionNotes({ transactionId, notes }: TransactionNotesProps) { const [showAddForm, setShowAddForm] = useState(false); const [noteToEdit, setNoteToEdit] = useState<Note | null>(null); const [noteToDelete, setNoteToDelete] = useState<Note | null>(null); // Sort notes by date (latest first) const sortedNotes = [...notes].sort( (a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime() ); return ( <Card> <CardHeader> <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-2"> <div> <CardTitle>Notes</CardTitle> <CardDescription> Your notes about this transaction </CardDescription> </div> <Button size="sm" onClick={() => setShowAddForm(true)}> <PlusIcon className="h-4 w-4 mr-2" /> Add Note </Button> </div> </CardHeader> <CardContent> {notes.length === 0 ? ( <div className="text-center py-6 text-muted-foreground"> <p>No notes for this transaction yet.</p> <Button variant="outline" size="sm" className="mt-2" onClick={() => setShowAddForm(true)} > Add your first note </Button> </div> ) : ( <div className="space-y-4"> {sortedNotes.map((note) => ( <div key={note.id} className="border rounded-md p-4" > <div className="flex items-center justify-between mb-2"> <div className="text-xs text-muted-foreground"> {formatDate(note.createdAt)} </div> <div className="flex gap-1"> <Button variant="ghost" size="icon" className="h-6 w-6" onClick={() => setNoteToEdit(note)} > <PencilIcon className="h-3 w-3" /> <span className="sr-only">Edit</span> </Button> <Button variant="ghost" size="icon" className="h-6 w-6 text-destructive" onClick={() => setNoteToDelete(note)} > <TrashIcon className="h-3 w-3" /> <span className="sr-only">Delete</span> </Button> </div> </div> <div className="text-sm whitespace-pre-wrap">{note.content}</div> </div> ))} </div> )} </CardContent> <AddNoteForm entityType="transaction" entityId={transactionId} open={showAddForm} onOpenChange={setShowAddForm} /> {noteToEdit && ( <EditNoteForm note={noteToEdit} entityType="transaction" entityId={transactionId} open={!!noteToEdit} onOpenChange={(open) => { if (!open) setNoteToEdit(null); }} /> )} {noteToDelete && ( <DeleteNoteDialog note={noteToDelete} open={!!noteToDelete} onOpenChange={(open) => { if (!open) setNoteToDelete(null); }} /> )} </Card> ); }
```

# src/components/transactions/transaction-actions.tsx

```tsx
"use client"; import { useState } from "react"; import { useRouter } from "next/navigation"; import { Button } from "@/components/ui/button"; import { PencilIcon, TrashIcon } from "lucide-react"; // Import the specific interface from EditTransactionForm import EditTransactionForm, { EditFormTransaction } from "@/components/transactions/edit-transaction-form"; import DeleteTransactionDialog from "@/components/transactions/delete-transaction-dialog"; import { Currency } from "@/lib/validators"; // Define the Stock interface locally, matching NestedStock in EditFormTransaction // This is also needed for the stocks prop of EditTransactionForm interface StockForEdit { id: string; ticker: string; name: string; currency: Currency; } interface TransactionActionsProps { transaction: EditFormTransaction; // Expect the imported interface directly } export default function TransactionActions({ transaction, // Prop should conform to EditFormTransaction }: TransactionActionsProps) { const router = useRouter(); const [showEditForm, setShowEditForm] = useState(false); const [showDeleteDialog, setShowDeleteDialog] = useState(false); // Prepare the object for DeleteTransactionDialog separately const transactionForDelete = { id: transaction.id, type: transaction.type, quantity: transaction.quantity, stock: { ticker: transaction.stock.ticker, name: transaction.stock.name, } }; // Construct the stock array needed for EditTransactionForm's 'stocks' prop // Type it explicitly const stockArrayForEdit: StockForEdit[] = [ { id: transaction.stock.id, ticker: transaction.stock.ticker, name: transaction.stock.name, currency: transaction.stock.currency } ]; return ( <div className="flex gap-2"> <Button variant="outline" size="sm" onClick={() => setShowEditForm(true)} > <PencilIcon className="h-4 w-4 mr-2" /> Edit </Button> <Button variant="outline" size="sm" className="text-destructive hover:text-destructive" onClick={() => setShowDeleteDialog(true)} > <TrashIcon className="h-4 w-4 mr-2" /> Delete </Button> {/* Pass an INLINE object literal that matches EditFormTransaction */} {/* This directly addresses the error pointing to line 53 */} <EditTransactionForm transaction={{ // Construct the object directly here id: transaction.id, type: transaction.type, quantity: transaction.quantity, price: transaction.price, currency: transaction.currency, // From correctly typed prop exchangeRate: transaction.exchangeRate, fxFee: transaction.fxFee, date: transaction.date, stock: { id: transaction.stock.id, ticker: transaction.stock.ticker, name: transaction.stock.name, currency: transaction.stock.currency, // From correctly typed prop }, }} stocks={stockArrayForEdit} // Pass the explicitly typed stock array open={showEditForm} onOpenChange={setShowEditForm} /> {/* DeleteTransactionDialog expects a simpler structure */} <DeleteTransactionDialog transaction={transactionForDelete} open={showDeleteDialog} onOpenChange={(open) => { if (!open) { setShowDeleteDialog(false); } else if (!open && !transaction.id) { router.push("/transactions"); } }} /> </div> ); }
```

# src/components/transactions/edit-transaction-form.tsx

```tsx
"use client"; import { useState, useEffect } from "react"; import { useForm } from "react-hook-form"; import { zodResolver } from "@hookform/resolvers/zod"; import { TransactionWithNoteFormValues, transactionWithNoteSchema, Currency, // Import Currency type } from "@/lib/validators"; import { updateTransaction } from "@/actions/transactions"; import { createNote } from "@/actions/notes"; import { TransactionType, TransactionTypeValue } from "@/lib/constants"; import { useToast } from "@/hooks/use-toast"; import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle, } from "@/components/ui/dialog"; import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage, FormDescription, } from "@/components/ui/form"; import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue, } from "@/components/ui/select"; import { Input } from "@/components/ui/input"; import { Button } from "@/components/ui/button"; import { CalendarIcon } from "lucide-react"; import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover"; import { Calendar } from "@/components/ui/calendar"; import { format } from "date-fns"; import { cn, formatCurrency, getCurrencySymbol } from "@/lib/utils"; import { Textarea } from "@/components/ui/textarea"; import { Checkbox } from "@/components/ui/checkbox"; import { getCurrentUser } from "@/actions/user"; // Define the nested Stock interface expected by Transaction interface NestedStock { id: string; ticker: string; name: string; currency: Currency; // <-- Use Currency enum here } // Export the Transaction interface expected by this component's props // Renamed slightly to avoid potential naming conflicts during import export interface EditFormTransaction { id: string; type: string; // Stays string as it comes from DB/enum value quantity: number; price: number; currency: Currency; // <-- Use Currency enum here exchangeRate?: number | null; fxFee?: number | null; date: Date; stock: NestedStock; // Use the updated NestedStock interface } // Define the Stock interface for the stocks prop (list of available stocks) interface Stock { id: string; ticker: string; name: string; currency: Currency; // <-- Use Currency enum here } interface EditTransactionFormProps { transaction: EditFormTransaction; // Use the exported interface name stocks: Stock[]; open: boolean; onOpenChange: (open: boolean) => void; } export default function EditTransactionForm({ transaction, stocks, open, onOpenChange, }: EditTransactionFormProps) { const { toast } = useToast(); const [isLoading, setIsLoading] = useState(false); const [includeNote, setIncludeNote] = useState(false); const [isForeignCurrency, setIsForeignCurrency] = useState( !!transaction.exchangeRate && transaction.exchangeRate !== 1 ); const [userDefaultCurrency, setUserDefaultCurrency] = useState<Currency>("GBP"); const [selectedStockCurrency, setSelectedStockCurrency] = useState<Currency>( transaction.stock.currency || "USD" ); const form = useForm<TransactionWithNoteFormValues>({ resolver: zodResolver(transactionWithNoteSchema), defaultValues: { stockId: transaction.stock.id, type: transaction.type as TransactionTypeValue, quantity: transaction.quantity, price: transaction.price, currency: transaction.currency || transaction.stock.currency || "USD", // Already Currency type exchangeRate: transaction.exchangeRate || 1, fxFee: transaction.fxFee || 0, date: new Date(transaction.date), includeNote: false, noteContent: "", }, }); // Get user's default currency useEffect(() => { const fetchUserCurrency = async () => { try { const user = await getCurrentUser(); setUserDefaultCurrency((user.defaultCurrency || "GBP") as Currency); } catch (error) { console.error("Error fetching user currency:", error); } }; if (open) { fetchUserCurrency(); } }, [open]); // Update form values when transaction changes useEffect(() => { form.reset({ stockId: transaction.stock.id, type: transaction.type as TransactionTypeValue, quantity: transaction.quantity, price: transaction.price, currency: transaction.currency || transaction.stock.currency || "USD", exchangeRate: transaction.exchangeRate || 1, fxFee: transaction.fxFee || 0, date: new Date(transaction.date), includeNote: false, noteContent: "", }); // Update stock currency state setSelectedStockCurrency(transaction.stock.currency); // Check if this was a foreign currency transaction const needsConversion = transaction.currency !== userDefaultCurrency; setIsForeignCurrency(needsConversion); setIncludeNote(false); }, [transaction, form, userDefaultCurrency]); // Handle stock selection change - update currency useEffect(() => { const subscription = form.watch((value, { name }) => { if (name === 'stockId') { const stockId = value.stockId; if (stockId && stockId !== transaction.stock.id) { const selectedStock = stocks.find(s => s.id === stockId); if (selectedStock) { setSelectedStockCurrency(selectedStock.currency); form.setValue("currency", selectedStock.currency); // Check if currency conversion is needed const needsConversion = selectedStock.currency !== userDefaultCurrency; setIsForeignCurrency(needsConversion); if (!needsConversion) { form.setValue("exchangeRate", 1); form.setValue("fxFee", 0); } } } } }); return () => subscription.unsubscribe(); }, [form.watch, stocks, transaction.stock.id, form, userDefaultCurrency]); // Handle the include note checkbox const handleIncludeNoteChange = (checked: boolean) => { setIncludeNote(checked); form.setValue("includeNote", checked); }; // Toggle foreign currency fields const handleForeignCurrencyToggle = (checked: boolean) => { setIsForeignCurrency(checked); if (!checked) { form.setValue("exchangeRate", 1); form.setValue("fxFee", 0); } }; // Calculate total cost based on current form values const calculateTotal = () => { const values = form.getValues(); const baseTotal = values.quantity * values.price; if (isForeignCurrency && values.exchangeRate) { const convertedTotal = baseTotal * values.exchangeRate; if (values.fxFee) { return values.type === TransactionType.BUY ? convertedTotal + values.fxFee : convertedTotal - values.fxFee; } return convertedTotal; } return baseTotal; }; const onSubmit = async (data: TransactionWithNoteFormValues) => { setIsLoading(true); try { // If not using foreign currency, set exchange rate to 1 and fx fee to 0 if (!isForeignCurrency) { data.exchangeRate = 1; data.fxFee = 0; } // Extract transaction data without note fields const transactionData = { stockId: data.stockId, type: data.type, quantity: data.quantity, price: data.price, currency: data.currency, exchangeRate: data.exchangeRate, fxFee: data.fxFee, date: data.date, }; // Update the transaction const result = await updateTransaction(transaction.id, transactionData); if (result.success) { // If including a note and transaction updated successfully if (data.includeNote && data.noteContent && result.data) { // Create note linked to the transaction await createNote({ content: data.noteContent, transactionId: result.data.id, }); } toast({ title: "Transaction updated", description: `Transaction for ${transaction.stock.ticker} has been updated (${getCurrencySymbol( data.currency )} ${data.price}).`, }); onOpenChange(false); } else { toast({ title: "Error", description: result.error || "Failed to update transaction.", variant: "destructive", }); } } catch (error) { toast({ title: "Error", description: "An unexpected error occurred.", variant: "destructive", }); } finally { setIsLoading(false); } }; return ( <Dialog open={open} onOpenChange={onOpenChange}> <DialogContent className="max-h-[90vh] overflow-y-auto"> <DialogHeader> <DialogTitle>Edit Transaction</DialogTitle> <DialogDescription> Update the transaction details for {transaction.stock.ticker} </DialogDescription> </DialogHeader> <Form {...form}> <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4"> <FormField control={form.control} name="stockId" render={({ field }) => ( <FormItem> <FormLabel>Stock</FormLabel> <Select onValueChange={(value) => { field.onChange(value); // Logic moved to useEffect watch }} defaultValue={field.value} > <FormControl> <SelectTrigger> <SelectValue placeholder="Select a stock" /> </SelectTrigger> </FormControl> <SelectContent> {stocks.map((stock) => ( <SelectItem key={stock.id} value={stock.id}> {stock.ticker}: {stock.name} ( {getCurrencySymbol(stock.currency)}) </SelectItem> ))} </SelectContent> </Select> <FormMessage /> </FormItem> )} /> <FormField control={form.control} name="type" render={({ field }) => ( <FormItem> <FormLabel>Transaction Type</FormLabel> <Select onValueChange={field.onChange} defaultValue={field.value} > <FormControl> <SelectTrigger> <SelectValue placeholder="Select transaction type" /> </SelectTrigger> </FormControl> <SelectContent> <SelectItem value={TransactionType.BUY}>Buy</SelectItem> <SelectItem value={TransactionType.SELL}>Sell</SelectItem> </SelectContent> </Select> <FormMessage /> </FormItem> )} /> <FormField control={form.control} name="quantity" render={({ field }) => ( <FormItem> <FormLabel>Quantity</FormLabel> <FormControl> <Input type="number" step="0.01" placeholder="10" {...field} onChange={(e) => field.onChange(parseFloat(e.target.value) || 0) } /> </FormControl> <FormMessage /> </FormItem> )} /> <FormField control={form.control} name="price" render={({ field }) => ( <FormItem> <FormLabel> Price per Share ({getCurrencySymbol(selectedStockCurrency)}) </FormLabel> <FormControl> <Input type="number" step="0.01" placeholder="150.00" {...field} onChange={(e) => field.onChange(parseFloat(e.target.value) || 0) } /> </FormControl> <FormDescription> Price in {selectedStockCurrency} currency </FormDescription> <FormMessage /> </FormItem> )} /> {/* Foreign Currency Checkbox - only show if stock currency differs from user default */} {selectedStockCurrency !== userDefaultCurrency && ( <FormItem className="flex flex-row items-start space-x-3 space-y-0 rounded-md border p-4"> <FormControl> <Checkbox checked={isForeignCurrency} onCheckedChange={handleForeignCurrencyToggle} /> </FormControl> <div className="space-y-1 leading-none"> <FormLabel>Currency Conversion Required</FormLabel> <FormDescription> The stock currency ({selectedStockCurrency}) differs from your default currency ({userDefaultCurrency}). Enable to specify exchange rate and fees. </FormDescription> </div> </FormItem> )} {/* Exchange Rate - only shown when foreign currency is enabled */} {isForeignCurrency && ( <FormField control={form.control} name="exchangeRate" render={({ field }) => ( <FormItem> <FormLabel> Exchange Rate ({selectedStockCurrency} to{" "} {userDefaultCurrency}) </FormLabel> <FormControl> <Input type="number" step="0.0001" placeholder="1.0" {...field} value={field.value || 1} onChange={(e) => field.onChange(parseFloat(e.target.value) || 1) } /> </FormControl> <FormDescription> Exchange rate to convert {selectedStockCurrency} to{" "} {userDefaultCurrency} </FormDescription> <FormMessage /> </FormItem> )} /> )} {/* FX Fee - only shown when foreign currency is enabled */} {isForeignCurrency && ( <FormField control={form.control} name="fxFee" render={({ field }) => ( <FormItem> <FormLabel> FX Fee ({getCurrencySymbol(userDefaultCurrency)}) </FormLabel> <FormControl> <Input type="number" step="0.01" placeholder="0.00" {...field} value={field.value || 0} onChange={(e) => field.onChange(parseFloat(e.target.value) || 0) } /> </FormControl> <FormDescription> Fee charged for currency conversion (in{" "} {userDefaultCurrency}) </FormDescription> <FormMessage /> </FormItem> )} /> )} {/* Display the total transaction value */} {form.getValues("quantity") > 0 && form.getValues("price") > 0 && ( <div className="text-sm bg-muted p-3 rounded-md"> <div className="font-medium">Transaction Total:</div> <div className="text-lg font-bold"> {formatCurrency(calculateTotal(), userDefaultCurrency)} </div> {isForeignCurrency && ( <div className="text-xs text-muted-foreground mt-1"> {form.getValues("quantity")} shares ×{" "} {getCurrencySymbol(selectedStockCurrency)}{" "} {form.getValues("price")} {isForeignCurrency ? " × " + form.getValues("exchangeRate") + " exchange rate" : ""} {isForeignCurrency && form.getValues("fxFee") ? (form.getValues("type") === TransactionType.BUY ? " + " : " - ") + getCurrencySymbol(userDefaultCurrency) + form.getValues("fxFee") + " FX fee" : ""} </div> )} </div> )} <FormField control={form.control} name="date" render={({ field }) => ( <FormItem className="flex flex-col"> <FormLabel>Transaction Date</FormLabel> <Popover> <PopoverTrigger asChild> <FormControl> <Button variant={"outline"} className={cn( "w-full pl-3 text-left font-normal", !field.value && "text-muted-foreground" )} > {field.value ? ( format(field.value, "PPP") ) : ( <span>Pick a date</span> )} <CalendarIcon className="ml-auto h-4 w-4 opacity-50" /> </Button> </FormControl> </PopoverTrigger> <PopoverContent className="w-auto p-0" align="start"> <Calendar mode="single" selected={field.value} onSelect={field.onChange} initialFocus /> </PopoverContent> </Popover> <FormMessage /> </FormItem> )} /> <FormField control={form.control} name="includeNote" render={({ field }) => ( <FormItem className="flex flex-row items-start space-x-3 space-y-0 rounded-md border p-4"> <FormControl> <Checkbox checked={field.value} onCheckedChange={(checked) => { field.onChange(checked); handleIncludeNoteChange(checked === true); }} /> </FormControl> <div className="space-y-1 leading-none"> <FormLabel> Add a note to this transaction </FormLabel> <FormDescription> Include notes about your investment decision or other details </FormDescription> </div> </FormItem> )} /> {includeNote && ( <FormField control={form.control} name="noteContent" render={({ field }) => ( <FormItem> <FormLabel>Note</FormLabel> <FormControl> <Textarea placeholder="Enter your note here..." className="min-h-32" {...field} /> </FormControl> <FormMessage /> </FormItem> )} /> )} <DialogFooter> <Button type="button" variant="outline" onClick={() => onOpenChange(false)} disabled={isLoading} > Cancel </Button> <Button type="submit" disabled={isLoading}> {isLoading ? "Saving..." : "Save Changes"} </Button> </DialogFooter> </form> </Form> </DialogContent> </Dialog> ); }
```

# src/components/transactions/delete-transaction-dialog.tsx

```tsx
"use client"; import { useState } from "react"; import { deleteTransaction } from "@/actions/transactions"; import { useToast } from "@/hooks/use-toast"; import { AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle, } from "@/components/ui/alert-dialog"; import { Button } from "@/components/ui/button"; import { TransactionType } from "@/lib/constants"; interface Transaction { id: string; type: string; quantity: number; stock: { ticker: string; name: string; }; } interface DeleteTransactionDialogProps { transaction: Transaction; open: boolean; onOpenChange: (open: boolean) => void; } export default function DeleteTransactionDialog({ transaction, open, onOpenChange, }: DeleteTransactionDialogProps) { const { toast } = useToast(); const [isLoading, setIsLoading] = useState(false); const handleDelete = async () => { setIsLoading(true); try { const result = await deleteTransaction(transaction.id); if (result.success) { toast({ title: "Transaction deleted", description: `${transaction.type === TransactionType.BUY ? "Buy" : "Sell"} transaction for ${transaction.stock.ticker} has been deleted.`, }); onOpenChange(false); } else { toast({ title: "Error", description: result.error || "Failed to delete transaction.", variant: "destructive", }); } } catch (error) { toast({ title: "Error", description: "An unexpected error occurred.", variant: "destructive", }); } finally { setIsLoading(false); } }; return ( <AlertDialog open={open} onOpenChange={onOpenChange}> <AlertDialogContent> <AlertDialogHeader> <AlertDialogTitle>Delete Transaction</AlertDialogTitle> <AlertDialogDescription> Are you sure you want to delete this {transaction.type === TransactionType.BUY ? "buy" : "sell"} transaction of {transaction.quantity} shares of {transaction.stock.ticker}? This action cannot be undone. </AlertDialogDescription> </AlertDialogHeader> <AlertDialogFooter> <AlertDialogCancel disabled={isLoading}>Cancel</AlertDialogCancel> <Button variant="destructive" onClick={handleDelete} disabled={isLoading} > {isLoading ? "Deleting..." : "Delete"} </Button> </AlertDialogFooter> </AlertDialogContent> </AlertDialog> ); }
```

# src/components/transactions/add-transaction-form.tsx

```tsx
"use client"; import { useState, useEffect } from "react"; import { useForm } from "react-hook-form"; import { zodResolver } from "@hookform/resolvers/zod"; import { TransactionWithNoteFormValues, transactionWithNoteSchema } from "@/lib/validators"; import { createTransaction } from "@/actions/transactions"; import { getStocks } from "@/actions/stocks"; import { useToast } from "@/hooks/use-toast"; import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle, } from "@/components/ui/dialog"; import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage, FormDescription, } from "@/components/ui/form"; import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue, } from "@/components/ui/select"; import { Input } from "@/components/ui/input"; import { Button } from "@/components/ui/button"; import { CalendarIcon } from "lucide-react"; import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover"; import { Calendar } from "@/components/ui/calendar"; import { format } from "date-fns"; import { cn, formatCurrency, getCurrencySymbol } from "@/lib/utils"; import { Textarea } from "@/components/ui/textarea"; import { Checkbox } from "@/components/ui/checkbox"; import { TransactionType, TransactionTypeValue } from "@/lib/constants"; import { getCurrentUser } from "@/actions/user"; import { Currency } from "@/lib/validators"; interface Stock { id: string; ticker: string; name: string; currency: string; } interface AddTransactionFormProps { stock?: Stock; open: boolean; onOpenChange: (open: boolean) => void; } export default function AddTransactionForm({ stock, open, onOpenChange, }: AddTransactionFormProps) { const { toast } = useToast(); const [isLoading, setIsLoading] = useState(false); const [stocks, setStocks] = useState<Stock[]>([]); const [includeNote, setIncludeNote] = useState(false); const [isForeignCurrency, setIsForeignCurrency] = useState(false); const [userDefaultCurrency, setUserDefaultCurrency] = useState<Currency>("GBP"); const [selectedStockCurrency, setSelectedStockCurrency] = useState<Currency>(stock?.currency as Currency || "USD"); const form = useForm<TransactionWithNoteFormValues>({ resolver: zodResolver(transactionWithNoteSchema), defaultValues: { stockId: stock?.id || "", type: TransactionType.BUY, quantity: 0, price: 0, currency: selectedStockCurrency, exchangeRate: 1, fxFee: 0, date: new Date(), includeNote: false, noteContent: "", }, }); // Get user's default currency useEffect(() => { const fetchUserCurrency = async () => { try { const user = await getCurrentUser(); setUserDefaultCurrency(user.defaultCurrency as Currency || "GBP"); } catch (error) { console.error("Error fetching user currency:", error); } }; if (open) { fetchUserCurrency(); } }, [open]); // Reset form when dialog closes useEffect(() => { if (!open) { form.reset({ stockId: stock?.id || "", type: TransactionType.BUY, quantity: 0, price: 0, currency: selectedStockCurrency, exchangeRate: 1, fxFee: 0, date: new Date(), includeNote: false, noteContent: "", }); setIncludeNote(false); } }, [open, form, stock, selectedStockCurrency]); // Load stocks when dialog opens useEffect(() => { const loadStocks = async () => { if (open && !stock) { try { const { success, data } = await getStocks(); if (success && data) { setStocks(data); } else { console.error("Error loading stocks"); toast({ title: "Error", description: "Failed to load stocks.", variant: "destructive", }); } } catch (error) { console.error("Error loading stocks:", error); toast({ title: "Error", description: "An unexpected error occurred.", variant: "destructive", }); } } else if (stock) { setStocks([stock]); } }; loadStocks(); }, [open, stock, toast]); // Handle stock selection change - update currency useEffect(() => { const stockId = form.getValues().stockId; if (stockId) { const selectedStock = stocks.find(s => s.id === stockId); if (selectedStock) { setSelectedStockCurrency(selectedStock.currency as Currency); form.setValue("currency", selectedStock.currency as Currency); // Check if currency conversion is needed const needsConversion = selectedStock.currency !== userDefaultCurrency; setIsForeignCurrency(needsConversion); if (!needsConversion) { form.setValue("exchangeRate", 1); form.setValue("fxFee", 0); } } } }, [form.getValues().stockId, stocks, form, userDefaultCurrency]); // Handle the include note checkbox const handleIncludeNoteChange = (checked: boolean) => { setIncludeNote(checked); form.setValue("includeNote", checked); }; // Toggle foreign currency fields const handleForeignCurrencyToggle = (checked: boolean) => { setIsForeignCurrency(checked); if (!checked) { form.setValue("exchangeRate", 1); form.setValue("fxFee", 0); } }; // Calculate total cost based on current form values const calculateTotal = () => { const values = form.getValues(); const baseTotal = values.quantity * values.price; if (isForeignCurrency && values.exchangeRate) { const convertedTotal = baseTotal * values.exchangeRate; if (values.fxFee) { return values.type === TransactionType.BUY ? convertedTotal + values.fxFee : convertedTotal - values.fxFee; } return convertedTotal; } return baseTotal; }; const onSubmit = async (data: TransactionWithNoteFormValues) => { setIsLoading(true); try { // If not using foreign currency, set exchange rate to 1 and fx fee to 0 if (!isForeignCurrency) { data.exchangeRate = 1; data.fxFee = 0; } const result = await createTransaction(data); if (result.success) { toast({ title: "Transaction added", description: `${data.type === TransactionType.BUY ? "Buy" : "Sell"} transaction added successfully.`, }); form.reset(); setIncludeNote(false); onOpenChange(false); } else { toast({ title: "Error", description: result.error || "Failed to add transaction.", variant: "destructive", }); } } catch (error) { toast({ title: "Error", description: "An unexpected error occurred.", variant: "destructive", }); } finally { setIsLoading(false); } }; return ( <Dialog open={open} onOpenChange={onOpenChange}> <DialogContent className="max-h-[90vh] overflow-y-auto"> <DialogHeader> <DialogTitle>Add Transaction</DialogTitle> <DialogDescription> {stock ? `Add a new transaction for ${stock.ticker}` : "Add a new transaction to your portfolio"} </DialogDescription> </DialogHeader> <Form {...form}> <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4"> <FormField control={form.control} name="stockId" render={({ field }) => ( <FormItem> <FormLabel>Stock</FormLabel> <Select onValueChange={(value) => { field.onChange(value); // Update currency when stock changes const selectedStock = stocks.find(s => s.id === value); if (selectedStock) { setSelectedStockCurrency(selectedStock.currency as Currency); form.setValue("currency", selectedStock.currency as Currency); // Check if currency conversion is needed const needsConversion = selectedStock.currency !== userDefaultCurrency; setIsForeignCurrency(needsConversion); if (!needsConversion) { form.setValue("exchangeRate", 1); form.setValue("fxFee", 0); } } }} defaultValue={field.value} disabled={!!stock} // Disable if stock is provided > <FormControl> <SelectTrigger> <SelectValue placeholder="Select a stock" /> </SelectTrigger> </FormControl> <SelectContent> {stocks.map((stock) => ( <SelectItem key={stock.id} value={stock.id}> {stock.ticker}: {stock.name} ({getCurrencySymbol(stock.currency)}) </SelectItem> ))} </SelectContent> </Select> <FormMessage /> </FormItem> )} /> <FormField control={form.control} name="type" render={({ field }) => ( <FormItem> <FormLabel>Transaction Type</FormLabel> <Select onValueChange={field.onChange} defaultValue={field.value} > <FormControl> <SelectTrigger> <SelectValue placeholder="Select transaction type" /> </SelectTrigger> </FormControl> <SelectContent> <SelectItem value={TransactionType.BUY}>Buy</SelectItem> <SelectItem value={TransactionType.SELL}>Sell</SelectItem> </SelectContent> </Select> <FormMessage /> </FormItem> )} /> <FormField control={form.control} name="quantity" render={({ field }) => ( <FormItem> <FormLabel>Quantity</FormLabel> <FormControl> <Input type="number" step="0.01" placeholder="10" {...field} onChange={(e) => field.onChange(parseFloat(e.target.value) || 0)} /> </FormControl> <FormMessage /> </FormItem> )} /> <FormField control={form.control} name="price" render={({ field }) => ( <FormItem> <FormLabel>Price per Share ({getCurrencySymbol(selectedStockCurrency)})</FormLabel> <FormControl> <Input type="number" step="0.01" placeholder="150.00" {...field} onChange={(e) => field.onChange(parseFloat(e.target.value) || 0)} /> </FormControl> <FormDescription> Price in {selectedStockCurrency} currency </FormDescription> <FormMessage /> </FormItem> )} /> {/* Foreign Currency Checkbox - only show if stock currency differs from user default */} {selectedStockCurrency !== userDefaultCurrency && ( <FormItem className="flex flex-row items-start space-x-3 space-y-0 rounded-md border p-4"> <FormControl> <Checkbox checked={isForeignCurrency} onCheckedChange={handleForeignCurrencyToggle} /> </FormControl> <div className="space-y-1 leading-none"> <FormLabel> Currency Conversion Required </FormLabel> <FormDescription> The stock currency ({selectedStockCurrency}) differs from your default currency ({userDefaultCurrency}). Enable to specify exchange rate and fees. </FormDescription> </div> </FormItem> )} {/* Exchange Rate - only shown when foreign currency is enabled */} {isForeignCurrency && ( <FormField control={form.control} name="exchangeRate" render={({ field }) => ( <FormItem> <FormLabel>Exchange Rate ({selectedStockCurrency} to {userDefaultCurrency})</FormLabel> <FormControl> <Input type="number" step="0.0001" placeholder="1.0" {...field} value={field.value || 1} onChange={(e) => field.onChange(parseFloat(e.target.value) || 1)} /> </FormControl> <FormDescription> Exchange rate to convert {selectedStockCurrency} to {userDefaultCurrency} </FormDescription> <FormMessage /> </FormItem> )} /> )} {/* FX Fee - only shown when foreign currency is enabled */} {isForeignCurrency && ( <FormField control={form.control} name="fxFee" render={({ field }) => ( <FormItem> <FormLabel>FX Fee ({getCurrencySymbol(userDefaultCurrency)})</FormLabel> <FormControl> <Input type="number" step="0.01" placeholder="0.00" {...field} value={field.value || 0} onChange={(e) => field.onChange(parseFloat(e.target.value) || 0)} /> </FormControl> <FormDescription> Fee charged for currency conversion (in {userDefaultCurrency}) </FormDescription> <FormMessage /> </FormItem> )} /> )} {/* Display the total transaction value */} {form.getValues("quantity") > 0 && form.getValues("price") > 0 && ( <div className="text-sm bg-muted p-3 rounded-md"> <div className="font-medium">Transaction Total:</div> <div className="text-lg font-bold"> {formatCurrency(calculateTotal(), userDefaultCurrency)} </div> {isForeignCurrency && ( <div className="text-xs text-muted-foreground mt-1"> {form.getValues("quantity")} shares × {getCurrencySymbol(selectedStockCurrency)} {form.getValues("price")} {isForeignCurrency ? " × " + form.getValues("exchangeRate") + " exchange rate" : ""} {isForeignCurrency && form.getValues("fxFee") ? (form.getValues("type") === TransactionType.BUY ? " + " : " - ") + getCurrencySymbol(userDefaultCurrency) + form.getValues("fxFee") + " FX fee" : ""} </div> )} </div> )} <FormField control={form.control} name="date" render={({ field }) => ( <FormItem className="flex flex-col"> <FormLabel>Transaction Date</FormLabel> <Popover> <PopoverTrigger asChild> <FormControl> <Button variant={"outline"} className={cn( "w-full pl-3 text-left font-normal", !field.value && "text-muted-foreground" )} > {field.value ? ( format(field.value, "PPP") ) : ( <span>Pick a date</span> )} <CalendarIcon className="ml-auto h-4 w-4 opacity-50" /> </Button> </FormControl> </PopoverTrigger> <PopoverContent className="w-auto p-0" align="start"> <Calendar mode="single" selected={field.value} onSelect={field.onChange} initialFocus /> </PopoverContent> </Popover> <FormMessage /> </FormItem> )} /> <FormField control={form.control} name="includeNote" render={({ field }) => ( <FormItem className="flex flex-row items-start space-x-3 space-y-0 rounded-md border p-4"> <FormControl> <Checkbox checked={field.value} onCheckedChange={(checked) => { field.onChange(checked); handleIncludeNoteChange(checked === true); }} /> </FormControl> <div className="space-y-1 leading-none"> <FormLabel> Add a note to this transaction </FormLabel> <FormDescription> Include notes about your investment decision or other details </FormDescription> </div> </FormItem> )} /> {includeNote && ( <FormField control={form.control} name="noteContent" render={({ field }) => ( <FormItem> <FormLabel>Note</FormLabel> <FormControl> <Textarea placeholder="Enter your note here..." className="min-h-32" {...field} /> </FormControl> <FormMessage /> </FormItem> )} /> )} <DialogFooter> <Button type="button" variant="outline" onClick={() => onOpenChange(false)} disabled={isLoading} > Cancel </Button> <Button type="submit" disabled={isLoading}> {isLoading ? "Adding..." : "Add Transaction"} </Button> </DialogFooter> </form> </Form> </DialogContent> </Dialog> ); }
```

# src/components/stocks/stocks-table.tsx

```tsx
// src/components/stocks/stocks-table.tsx "use client"; import { useState } from "react"; import Link from "next/link"; import { Card, CardContent } from "@/components/ui/card"; import { Input } from "@/components/ui/input"; import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger, } from "@/components/ui/dropdown-menu"; import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue, } from "@/components/ui/select"; import { Button } from "@/components/ui/button"; import { MoreHorizontalIcon, PencilIcon, TrashIcon, FileTextIcon, } from "lucide-react"; import { formatCurrency, getCurrencySymbol } from "@/lib/utils"; import EditStockForm from "@/components/stocks/edit-stock-form"; import DeleteStockDialog from "@/components/stocks/delete-stock-dialog"; import { Currency } from "@/lib/validators"; // Export the Stock interface export interface Stock { id: string; ticker: string; name: string; sectorId: string | null; sector: { id: string; name: string } | null; averagePrice: number; holdings: number; value: number; currency: Currency; // Expects Currency type transactions: number; // Expects number (count) notes?: { id: string; content: string; }[]; } interface Sector { id: string; name: string; } interface StocksTableProps { stocks: Stock[]; // Uses the exported interface sectors: Sector[]; } export default function StocksTable({ stocks, sectors }: StocksTableProps) { const [search, setSearch] = useState(""); const [sectorFilter, setSectorFilter] = useState("all"); const [sortBy, setSortBy] = useState<keyof Stock | "sector">("ticker"); const [sortDirection, setSortDirection] = useState<"asc" | "desc">("asc"); const [stockToEdit, setStockToEdit] = useState<Stock | null>(null); const [stockToDelete, setStockToDelete] = useState<Stock | null>(null); // Apply filters let filteredStocks = [...stocks]; // Apply search filter if (search) { const searchLower = search.toLowerCase(); filteredStocks = filteredStocks.filter( (stock) => stock.ticker.toLowerCase().includes(searchLower) || stock.name.toLowerCase().includes(searchLower) ); } // Apply sector filter if (sectorFilter !== "all") { filteredStocks = filteredStocks.filter( (stock) => stock.sectorId === sectorFilter ); } // Apply sorting filteredStocks.sort((a, b) => { if (sortBy === "sector") { const valueA = a.sector?.name || ""; const valueB = b.sector?.name || ""; return sortDirection === "asc" ? valueA.localeCompare(valueB) : valueB.localeCompare(valueA); } if (sortBy === "currency") { const valueA = a.currency || ""; const valueB = b.currency || ""; return sortDirection === "asc" ? valueA.localeCompare(valueB) : valueB.localeCompare(valueA); } const valueA = a[sortBy]; const valueB = b[sortBy]; if (typeof valueA === "string" && typeof valueB === "string") { return sortDirection === "asc" ? valueA.localeCompare(valueB) : valueB.localeCompare(valueA); } if (typeof valueA === "number" && typeof valueB === "number") { return sortDirection === "asc" ? valueA - valueB : valueB - valueA; } return 0; }); // Toggle sort direction when clicking on the same column const handleSort = (column: keyof Stock | "sector") => { if (sortBy === column) { setSortDirection(sortDirection === "asc" ? "desc" : "asc"); } else { setSortBy(column); setSortDirection("asc"); } }; return ( <> <div className="flex flex-col sm:flex-row gap-4 mb-4"> <Input placeholder="Search stocks..." value={search} onChange={(e) => setSearch(e.target.value)} className="sm:max-w-xs" /> <Select value={sectorFilter} onValueChange={setSectorFilter}> <SelectTrigger className="sm:max-w-xs"> <SelectValue placeholder="Filter by sector" /> </SelectTrigger> <SelectContent> <SelectItem value="all">All Sectors</SelectItem> {sectors.map((sector) => ( <SelectItem key={sector.id} value={sector.id}> {sector.name} </SelectItem> ))} </SelectContent> </Select> </div> <Card> <CardContent className="p-0"> <div className="overflow-x-auto"> <table className="w-full text-sm"> <thead> <tr className="border-b"> <th className="text-left font-medium py-4 px-6 cursor-pointer hover:bg-muted/50" onClick={() => handleSort("ticker")} > Ticker{" "} {sortBy === "ticker" && ( <span className="ml-1"> {sortDirection === "asc" ? "↑" : "↓"} </span> )} </th> <th className="text-left font-medium py-4 px-6 cursor-pointer hover:bg-muted/50" onClick={() => handleSort("name")} > Company{" "} {sortBy === "name" && ( <span className="ml-1"> {sortDirection === "asc" ? "↑" : "↓"} </span> )} </th> <th className="text-left font-medium py-4 px-6 cursor-pointer hover:bg-muted/50" onClick={() => handleSort("sector")} > Sector{" "} {sortBy === "sector" && ( <span className="ml-1"> {sortDirection === "asc" ? "↑" : "↓"} </span> )} </th> <th className="text-center font-medium py-4 px-3 cursor-pointer hover:bg-muted/50" onClick={() => handleSort("currency")} > Currency{' '} {sortBy === 'currency' && <span className="ml-1">{sortDirection === 'asc' ? '↑' : '↓'}</span>} </th> <th className="text-right font-medium py-4 px-6 cursor-pointer hover:bg-muted/50" onClick={() => handleSort("holdings")} > Shares{" "} {sortBy === "holdings" && ( <span className="ml-1"> {sortDirection === "asc" ? "↑" : "↓"} </span> )} </th> <th className="text-right font-medium py-4 px-6 cursor-pointer hover:bg-muted/50" onClick={() => handleSort("averagePrice")} > Avg Price{" "} {sortBy === "averagePrice" && ( <span className="ml-1"> {sortDirection === "asc" ? "↑" : "↓"} </span> )} </th> <th className="text-right font-medium py-4 px-6 cursor-pointer hover:bg-muted/50" onClick={() => handleSort("value")} > Value{" "} {sortBy === "value" && ( <span className="ml-1"> {sortDirection === "asc" ? "↑" : "↓"} </span> )} </th> <th className="text-center font-medium py-4 px-6">Notes</th> <th className="text-right font-medium py-4 px-6"></th> </tr> </thead> <tbody className="divide-y"> {filteredStocks.length === 0 ? ( <tr> <td colSpan={9} // Adjusted colspan className="py-6 text-center text-muted-foreground" > {stocks.length === 0 ? "No stocks in your portfolio. Add your first stock to get started." : "No stocks match your filters."} </td> </tr> ) : ( filteredStocks.map((stock) => ( <tr key={stock.id} className="hover:bg-muted/50"> <td className="py-4 px-6"> <Link href={`/stocks/${stock.id}`} className="font-medium hover:underline" > {stock.ticker} </Link> </td> <td className="py-4 px-6">{stock.name}</td> <td className="py-4 px-6">{stock.sector?.name || "—"}</td> <td className="py-4 px-3 text-center"> <span className="text-xs font-medium"> {getCurrencySymbol(stock.currency)} {stock.currency} </span> </td> <td className="py-4 px-6 text-right"> {stock.holdings > 0 ? stock.holdings.toFixed(2) : "0.00"} </td> <td className="py-4 px-6 text-right"> {stock.averagePrice > 0 ? formatCurrency(stock.averagePrice, stock.currency) // Use stock currency : "—"} </td> <td className="py-4 px-6 text-right font-medium"> {formatCurrency(stock.value, stock.currency)} {/* Use stock currency */} </td> <td className="py-4 px-6 text-center"> {stock.notes && stock.notes.length > 0 ? ( <div className="relative group inline-flex justify-center"> <div className="cursor-pointer hover:text-primary"> <FileTextIcon className="h-5 w-5" /> </div> <div className="invisible absolute z-10 w-64 -translate-x-1/2 -translate-y-8 rounded-md border bg-popover px-3 py-2 text-xs text-popover-foreground opacity-0 shadow-md transition-all group-hover:visible group-hover:opacity-100"> <div className="font-semibold mb-1"> {stock.notes.length}{" "} {stock.notes.length === 1 ? "note" : "notes"} </div> <div className="line-clamp-2 text-muted-foreground"> {stock.notes[0].content} </div> <div className="text-right mt-1"> <Link href={`/stocks/${stock.id}`} className="text-primary text-xs hover:underline" > View all </Link> </div> </div> </div> ) : ( <span className="text-muted-foreground text-xs"> No notes </span> )} </td> <td className="py-4 px-6 text-right"> <DropdownMenu> <DropdownMenuTrigger asChild> <Button variant="ghost" size="sm"> <MoreHorizontalIcon className="h-4 w-4" /> <span className="sr-only">Actions</span> </Button> </DropdownMenuTrigger> <DropdownMenuContent align="end"> <DropdownMenuItem onClick={() => setStockToEdit(stock)} // stock already includes currency here className="cursor-pointer" > <PencilIcon className="mr-2 h-4 w-4" /> Edit </DropdownMenuItem> <DropdownMenuItem onClick={() => setStockToDelete(stock)} // stock already includes currency here className="cursor-pointer text-destructive focus:text-destructive" > <TrashIcon className="mr-2 h-4 w-4" /> Delete </DropdownMenuItem> </DropdownMenuContent> </DropdownMenu> </td> </tr> )) )} </tbody> </table> </div> </CardContent> </Card> {stockToEdit && ( <EditStockForm stock={stockToEdit} // Pass the stock object which now matches the required type open={!!stockToEdit} onOpenChange={(open) => { if (!open) setStockToEdit(null); }} /> )} {stockToDelete && ( <DeleteStockDialog stock={stockToDelete} // Pass the stock object open={!!stockToDelete} onOpenChange={(open) => { if (!open) setStockToDelete(null); }} /> )} </> ); }
```

# src/components/stocks/stocks-header.tsx

```tsx
"use client"; import { useState } from "react"; import { Button } from "@/components/ui/button"; import { PlusIcon } from "lucide-react"; import AddStockForm from "@/components/stocks/add-stock-form"; export default function StocksHeader() { const [showAddForm, setShowAddForm] = useState(false); return ( <div className="flex flex-col gap-4 sm:flex-row sm:items-center sm:justify-between"> <div> <h2 className="text-2xl font-bold tracking-tight">Stocks</h2> <p className="text-muted-foreground"> Manage your stock portfolio and view positions </p> </div> <Button onClick={() => setShowAddForm(true)} className="sm:w-auto w-full"> <PlusIcon className="mr-2 h-4 w-4" /> Add Stock </Button> <AddStockForm open={showAddForm} onOpenChange={setShowAddForm} /> </div> ); }
```

# src/components/stocks/stock-transactions.tsx

```tsx
// src/components/stocks/stock-transactions.tsx "use client"; import { useState } from "react"; import { Card, CardContent, CardDescription, CardHeader, CardTitle, } from "@/components/ui/card"; import { Button } from "@/components/ui/button"; import { formatCurrency, formatDate } from "@/lib/utils"; import { PlusIcon, ArrowUpIcon, ArrowDownIcon } from "lucide-react"; import Link from "next/link"; import AddTransactionForm from "@/components/transactions/add-transaction-form"; import { TransactionType } from "@/lib/constants"; import { Currency } from "@/lib/validators"; // Import the Currency type interface Transaction { id: string; type: string; quantity: number; price: number; currency: Currency; // Add currency here too for consistency date: Date; } interface Stock { id: string; ticker: string; name: string; currency: Currency; // <-- Add the currency field here } interface StockTransactionsProps { stock: Stock; transactions: Transaction[]; } export default function StockTransactions({ stock, transactions, }: StockTransactionsProps) { const [showAddForm, setShowAddForm] = useState(false); // Sort transactions by date (latest first) const sortedTransactions = [...transactions].sort( (a, b) => new Date(b.date).getTime() - new Date(a.date).getTime() ); return ( <Card> <CardHeader> <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-2"> <div> <CardTitle>Transaction History</CardTitle> <CardDescription> Buy and sell transactions for {stock.ticker} </CardDescription> </div> <Button size="sm" onClick={() => setShowAddForm(true)}> <PlusIcon className="h-4 w-4 mr-2" /> Add Transaction </Button> </div> </CardHeader> <CardContent> {transactions.length === 0 ? ( <div className="text-center py-6 text-muted-foreground"> <p>No transactions for this stock yet.</p> <Button variant="outline" size="sm" className="mt-2" onClick={() => setShowAddForm(true)} > Add your first transaction </Button> </div> ) : ( <div className="space-y-4"> {sortedTransactions.map((transaction) => ( <div key={transaction.id} className="flex items-center border-b pb-4 last:border-0 last:pb-0" > <div className={`mr-3 flex h-9 w-9 items-center justify-center rounded-full ${transaction.type === TransactionType.BUY ? "bg-green-100 dark:bg-green-900" : "bg-red-100 dark:bg-red-900" }`} > {transaction.type === TransactionType.BUY ? ( <ArrowDownIcon className="h-4 w-4 text-green-600 dark:text-green-400" /> ) : ( <ArrowUpIcon className="h-4 w-4 text-red-600 dark:text-red-400" /> )} </div> <div className="flex-1 space-y-1"> <div className="flex items-center"> <Link href={`/transactions/${transaction.id}`} className="text-sm font-medium leading-none hover:underline" > {transaction.type === TransactionType.BUY ? "Bought" : "Sold"}{" "} {transaction.quantity.toFixed(2)} shares </Link> <div className="ml-auto text-xs text-muted-foreground"> {formatDate(transaction.date)} </div> </div> <p className="text-xs text-muted-foreground"> @ {formatCurrency(transaction.price, transaction.currency)} per share •{" "} {formatCurrency(transaction.price * transaction.quantity, transaction.currency)} total </p> </div> </div> ))} </div> )} </CardContent> <AddTransactionForm stock={stock} // This stock object now includes the currency open={showAddForm} onOpenChange={setShowAddForm} /> </Card> ); }
```

# src/components/stocks/stock-notes.tsx

```tsx
"use client"; import { useState } from "react"; import { Card, CardContent, CardDescription, CardHeader, CardTitle, } from "@/components/ui/card"; import { Button } from "@/components/ui/button"; import { formatDate } from "@/lib/utils"; import { PlusIcon, PencilIcon, TrashIcon } from "lucide-react"; import AddNoteForm from "@/components/notes/add-note-form"; import EditNoteForm from "@/components/notes/edit-note-form"; import DeleteNoteDialog from "@/components/notes/delete-note-dialog"; interface Note { id: string; content: string; createdAt: Date; } interface StockNotesProps { stockId: string; notes: Note[]; } export default function StockNotes({ stockId, notes }: StockNotesProps) { const [showAddForm, setShowAddForm] = useState(false); const [noteToEdit, setNoteToEdit] = useState<Note | null>(null); const [noteToDelete, setNoteToDelete] = useState<Note | null>(null); // Sort notes by date (latest first) const sortedNotes = [...notes].sort( (a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime() ); return ( <Card> <CardHeader> <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-2"> <div> <CardTitle>Notes</CardTitle> <CardDescription> Your notes about this stock </CardDescription> </div> <Button size="sm" onClick={() => setShowAddForm(true)}> <PlusIcon className="h-4 w-4 mr-2" /> Add Note </Button> </div> </CardHeader> <CardContent> {notes.length === 0 ? ( <div className="text-center py-6 text-muted-foreground"> <p>No notes for this stock yet.</p> <Button variant="outline" size="sm" className="mt-2" onClick={() => setShowAddForm(true)} > Add your first note </Button> </div> ) : ( <div className="space-y-4"> {sortedNotes.map((note) => ( <div key={note.id} className="border rounded-md p-4" > <div className="flex items-center justify-between mb-2"> <div className="text-xs text-muted-foreground"> {formatDate(note.createdAt)} </div> <div className="flex gap-1"> <Button variant="ghost" size="icon" className="h-6 w-6" onClick={() => setNoteToEdit(note)} > <PencilIcon className="h-3 w-3" /> <span className="sr-only">Edit</span> </Button> <Button variant="ghost" size="icon" className="h-6 w-6 text-destructive" onClick={() => setNoteToDelete(note)} > <TrashIcon className="h-3 w-3" /> <span className="sr-only">Delete</span> </Button> </div> </div> <div className="text-sm whitespace-pre-wrap">{note.content}</div> </div> ))} </div> )} </CardContent> <AddNoteForm entityType="stock" entityId={stockId} open={showAddForm} onOpenChange={setShowAddForm} /> {noteToEdit && ( <EditNoteForm note={noteToEdit} entityType="stock" entityId={stockId} open={!!noteToEdit} onOpenChange={(open) => { if (!open) setNoteToEdit(null); }} /> )} {noteToDelete && ( <DeleteNoteDialog note={noteToDelete} open={!!noteToDelete} onOpenChange={(open) => { if (!open) setNoteToDelete(null); }} /> )} </Card> ); }
```

# src/components/stocks/stock-header.tsx

```tsx
// src/components/stocks/stock-header.tsx "use client"; import { useState } from "react"; import Link from "next/link"; import { Button } from "@/components/ui/button"; import { PencilIcon, ChevronLeftIcon, TrashIcon } from "lucide-react"; import { formatCurrency } from "@/lib/utils"; import EditStockForm from "@/components/stocks/edit-stock-form"; import DeleteStockDialog from "@/components/stocks/delete-stock-dialog"; import { Currency } from "@/lib/validators"; // Import the Currency type interface Stock { id: string; ticker: string; name: string; sectorId: string | null; sector: { id: string; name: string } | null; averagePrice: number; holdings: number; value: number; currency: Currency; // <-- Add the currency field here transactions: { id: string }[]; notes?: { id: string; content: string }[]; // Make notes optional if they might not exist } interface StockHeaderProps { stock: Stock; } export default function StockHeader({ stock }: StockHeaderProps) { const [showEditForm, setShowEditForm] = useState(false); const [showDeleteDialog, setShowDeleteDialog] = useState(false); // Ensure stock.notes exists before passing to DeleteStockDialog const stockToDelete = { ...stock, transactions: stock.transactions.length, // Keep this }; // Ensure the stock object passed to EditStockForm matches its expected type // Notes should be optional in EditStockForm's props, but we'll ensure it's passed correctly const stockToEdit = { ...stock, notes: stock.notes || [], // Pass notes, defaulting to empty array if undefined }; return ( <div className="flex flex-col gap-4 sm:flex-row sm:items-center sm:justify-between"> <div> <Link href="/stocks" className="inline-flex items-center gap-1 text-sm text-muted-foreground hover:text-foreground mb-2" > <ChevronLeftIcon className="h-4 w-4" /> Back to Stocks </Link> <h2 className="text-3xl font-bold tracking-tight"> {stock.ticker}: {stock.name} </h2> <div className="flex flex-wrap items-center gap-2 mt-1"> <div className="text-muted-foreground"> {stock.sector?.name || "No sector"} • </div> <div className="font-medium"> {stock.holdings > 0 ? `${stock.holdings.toFixed(2)} shares @ ${formatCurrency(stock.averagePrice, stock.currency)}` // Use stock currency : "No shares"} </div> {stock.holdings > 0 && ( <div className="text-muted-foreground"> • Total value: {formatCurrency(stock.value, stock.currency)} {/* Use stock currency */} </div> )} </div> </div> <div className="flex gap-2"> <Button variant="outline" size="sm" onClick={() => setShowEditForm(true)}> <PencilIcon className="h-4 w-4 mr-2" /> Edit </Button> <Button variant="outline" size="sm" className="text-destructive hover:text-destructive" onClick={() => setShowDeleteDialog(true)} > <TrashIcon className="h-4 w-4 mr-2" /> Delete </Button> </div> {/* Pass the correctly typed stock object */} <EditStockForm stock={stockToEdit} // Pass stockToEdit which includes currency and notes open={showEditForm} onOpenChange={setShowEditForm} /> <DeleteStockDialog stock={stockToDelete} // Pass stockToDelete open={showDeleteDialog} onOpenChange={setShowDeleteDialog} /> </div> ); }
```

# src/components/stocks/stock-details.tsx

```tsx
import { Card, CardContent, CardDescription, CardHeader, CardTitle, } from "@/components/ui/card"; import { formatCurrency, formatDate } from "@/lib/utils"; import { Currency } from "@/lib/validators"; interface Stock { id: string; ticker: string; name: string; createdAt: Date; sector: { id: string; name: string } | null; averagePrice: number; holdings: number; value: number; currency: Currency; transactions: { id: string }[]; } interface StockDetailsProps { stock: Stock; } export default function StockDetails({ stock }: StockDetailsProps) { const { currency } = stock; return ( <Card> <CardHeader> <CardTitle>Stock Details</CardTitle> <CardDescription> Key information about {stock.ticker} </CardDescription> </CardHeader> <CardContent> <div className="space-y-4"> {/* static fields */} <div className="grid grid-cols-2 gap-4"> <Field label="Ticker" value={stock.ticker} /> <Field label="Company" value={stock.name} /> <Field label="Sector" value={stock.sector?.name || "—"} /> <Field label="Added" value={formatDate(stock.createdAt)} /> </div> {/* dynamic fields */} <div className="border-t pt-4"> <div className="grid grid-cols-2 gap-4"> <Field label="Shares" value={ stock.holdings > 0 ? stock.holdings.toFixed(2) : "0.00" } /> <Field label="Average Price" value={ stock.averagePrice > 0 ? formatCurrency(stock.averagePrice, currency) : "—" } /> <Field label="Total Value" value={formatCurrency(stock.value, currency)} /> <Field label="Transactions" value={stock.transactions.length.toString()} /> </div> </div> </div> </CardContent> </Card> ); } function Field({ label, value, }: { label: string; value: React.ReactNode; }) { return ( <div> <div className="text-sm font-medium text-muted-foreground"> {label} </div> <div className="text-lg font-medium">{value}</div> </div> ); }
```

# src/components/stocks/edit-stock-form.tsx

```tsx
"use client"; import { useState, useEffect } from "react"; import { useForm } from "react-hook-form"; import { zodResolver } from "@hookform/resolvers/zod"; import { StockWithNoteFormValues, stockWithNoteSchema, Currency } from "@/lib/validators"; import { updateStock, getSectors } from "@/actions/stocks"; import { createNote, getNotesByStockId } from "@/actions/notes"; import { useToast } from "@/hooks/use-toast"; import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle, } from "@/components/ui/dialog"; import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage, FormDescription, } from "@/components/ui/form"; import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue, } from "@/components/ui/select"; import { Input } from "@/components/ui/input"; import { Button } from "@/components/ui/button"; import { Textarea } from "@/components/ui/textarea"; import { Checkbox } from "@/components/ui/checkbox"; import { getCurrencySymbol } from "@/lib/utils"; import { getCurrentUser } from "@/actions/user"; interface Stock { id: string; ticker: string; name: string; sectorId: string | null; currency: Currency; notes?: { id: string; content: string; }[]; } interface EditStockFormProps { stock: Stock; open: boolean; onOpenChange: (open: boolean) => void; } export default function EditStockForm({ stock, open, onOpenChange }: EditStockFormProps) { const { toast } = useToast(); const [isLoading, setIsLoading] = useState(false); const [sectors, setSectors] = useState<{ id: string; name: string }[]>([]); const [includeNewNote, setIncludeNewNote] = useState(false); const [sectorLoadError, setSectorLoadError] = useState<string | null>(null); const [existingNotes, setExistingNotes] = useState<{ id: string; content: string }[]>([]); const [loadingNotes, setLoadingNotes] = useState(false); const [notesLoadError, setNotesLoadError] = useState<string | null>(null); const [userDefaultCurrency, setUserDefaultCurrency] = useState<Currency>("GBP"); const form = useForm<StockWithNoteFormValues>({ resolver: zodResolver(stockWithNoteSchema), defaultValues: { ticker: stock.ticker, name: stock.name, sectorId: stock.sectorId || "none", currency: stock.currency || "USD", includeNote: false, noteContent: "", }, }); // Get user's default currency useEffect(() => { const fetchUserCurrency = async () => { try { const user = await getCurrentUser(); // Cast to Currency to ensure it's one of the allowed values setUserDefaultCurrency((user.defaultCurrency || "GBP") as Currency); } catch (error) { console.error("Error fetching user currency:", error); } }; if (open) { fetchUserCurrency(); } }, [open]); // Load sectors when dialog opens useEffect(() => { const loadSectors = async () => { if (open && sectors.length === 0) { setIsLoading(true); try { const { success, data, error } = await getSectors(); if (success && data) { setSectors(data); setSectorLoadError(null); } else { console.error("Error loading sectors:", error); setSectorLoadError(error || "Failed to load sectors."); toast({ title: "Error loading sectors", description: error || "Failed to load sectors.", variant: "destructive", }); } } catch (error) { console.error("Unexpected error loading sectors:", error); setSectorLoadError("An unexpected error occurred while loading sectors."); toast({ title: "Error loading sectors", description: "An unexpected error occurred.", variant: "destructive", }); } finally { setIsLoading(false); } } }; loadSectors(); }, [open, sectors.length, toast]); // Load existing notes when dialog opens and stock ID is available useEffect(() => { const loadExistingNotes = async () => { if (open && stock?.id) { setLoadingNotes(true); try { const { success, data, error } = await getNotesByStockId(stock.id); if (success && data) { setExistingNotes(data); setNotesLoadError(null); } else { console.error("Error loading notes:", error); setNotesLoadError(error || "Failed to load notes."); } } catch (error) { console.error("Unexpected error loading notes:", error); setNotesLoadError("An unexpected error occurred while loading notes."); } finally { setLoadingNotes(false); } } else { setExistingNotes([]); // Clear notes if dialog is closed or no stock } }; loadExistingNotes(); }, [open, stock?.id]); // Reset includeNewNote state and form values on open useEffect(() => { if (open) { setIncludeNewNote(false); form.setValue("includeNote", false); form.setValue("noteContent", ""); } }, [open, form]); // Update form values when stock prop changes useEffect(() => { form.reset({ ticker: stock.ticker, name: stock.name, sectorId: stock.sectorId || "none", currency: stock.currency || "USD", includeNote: false, noteContent: "", }); setIncludeNewNote(false); }, [stock, form]); // Handle the include new note checkbox const handleIncludeNewNoteChange = (checked: boolean) => { setIncludeNewNote(checked); form.setValue("includeNote", checked); // Update form value for validation }; const onSubmit = async (data: StockWithNoteFormValues) => { setIsLoading(true); try { const stockData = { ticker: data.ticker, name: data.name, sectorId: data.sectorId, currency: data.currency, }; const result = await updateStock(stock.id, stockData); if (result.success) { // If including a new note and note content is provided if (data.includeNote && data.noteContent) { const noteResult = await createNote({ content: data.noteContent, stockId: stock.id, }); if (!noteResult.success) { toast({ title: "Warning", description: noteResult.error || "Note could not be added.", variant: "default", }); } } const currencySymbol = getCurrencySymbol(data.currency); toast({ title: "Stock updated", description: `${data.ticker} has been updated (${currencySymbol} ${data.currency}).`, }); onOpenChange(false); } else { toast({ title: "Error", description: result.error || "Failed to update stock.", variant: "destructive", }); } } catch (error) { toast({ title: "Error", description: "An unexpected error occurred.", variant: "destructive", }); } finally { setIsLoading(false); } }; return ( <Dialog open={open} onOpenChange={onOpenChange}> <DialogContent className="max-h-[90vh] overflow-y-auto"> <DialogHeader> <DialogTitle>Edit Stock</DialogTitle> <DialogDescription> Update stock information and view or add new notes. </DialogDescription> </DialogHeader> {/* Display Existing Notes */} {loadingNotes ? ( <p className="text-muted-foreground text-sm">Loading existing notes...</p> ) : notesLoadError ? ( <p className="text-destructive text-sm">Error loading notes: {notesLoadError}</p> ) : existingNotes.length > 0 ? ( <div className="mb-4"> <h3 className="text-sm font-semibold mb-2">Existing Notes</h3> <ul className="list-disc pl-4 text-sm text-muted-foreground"> {existingNotes.map((note) => ( <li key={note.id}>{note.content}</li> ))} </ul> </div> ) : ( <p className="text-muted-foreground text-sm mb-4">No existing notes for this stock.</p> )} <Form {...form}> <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4"> {/* Ticker and Name fields remain the same */} <FormField control={form.control} name="ticker" render={({ field }) => ( <FormItem> <FormLabel>Ticker Symbol</FormLabel> <FormControl> <Input placeholder="AAPL" {...field} value={field.value} onChange={(e) => field.onChange(e.target.value.toUpperCase())} /> </FormControl> <FormMessage /> </FormItem> )} /> <FormField control={form.control} name="name" render={({ field }) => ( <FormItem> <FormLabel>Company Name</FormLabel> <FormControl> <Input placeholder="Apple Inc." {...field} /> </FormControl> <FormMessage /> </FormItem> )} /> <FormField control={form.control} name="currency" render={({ field }) => ( <FormItem> <FormLabel>Currency</FormLabel> <Select onValueChange={field.onChange} defaultValue={field.value} > <FormControl> <SelectTrigger> <SelectValue placeholder="Select a currency" /> </SelectTrigger> </FormControl> <SelectContent> <SelectItem value="USD">{getCurrencySymbol("USD")} USD - US Dollar</SelectItem> <SelectItem value="GBP">{getCurrencySymbol("GBP")} GBP - British Pound</SelectItem> <SelectItem value="EUR">{getCurrencySymbol("EUR")} EUR - Euro</SelectItem> <SelectItem value="JPY">{getCurrencySymbol("JPY")} JPY - Japanese Yen</SelectItem> <SelectItem value="CHF">{getCurrencySymbol("CHF")} CHF - Swiss Franc</SelectItem> <SelectItem value="CAD">{getCurrencySymbol("CAD")} CAD - Canadian Dollar</SelectItem> <SelectItem value="AUD">{getCurrencySymbol("AUD")} AUD - Australian Dollar</SelectItem> </SelectContent> </Select> <FormDescription> {field.value !== userDefaultCurrency ? `This differs from your default currency (${getCurrencySymbol(userDefaultCurrency)} ${userDefaultCurrency}). Exchange rates will be needed for transactions.` : `This matches your default currency (${getCurrencySymbol(userDefaultCurrency)} ${userDefaultCurrency}).` } </FormDescription> <FormMessage /> </FormItem> )} /> <FormField control={form.control} name="sectorId" render={({ field }) => ( <FormItem> <FormLabel>Sector</FormLabel> <Select onValueChange={(value) => field.onChange(value)} value={field.value || "none"} disabled={isLoading || (sectorLoadError !== null && sectors.length === 0)} > <FormControl> <SelectTrigger> <SelectValue placeholder={sectorLoadError || "Select a sector"} /> </SelectTrigger> </FormControl> <SelectContent> <SelectItem value="none">None</SelectItem> {sectors.map((sector) => ( <SelectItem key={sector.id} value={sector.id}> {sector.name} </SelectItem> ))} </SelectContent> </Select> <FormMessage /> {sectorLoadError && ( <FormMessage className="text-destructive"> {sectorLoadError} </FormMessage> )} </FormItem> )} /> <FormField control={form.control} name="includeNote" render={({ field }) => ( <FormItem className="flex flex-row items-start space-x-3 space-y-0 rounded-md border p-4"> <FormControl> <Checkbox checked={field.value} onCheckedChange={(checked) => { field.onChange(checked); handleIncludeNewNoteChange(checked === true); // Use the new handler }} /> </FormControl> <div className="space-y-1 leading-none"> <FormLabel> Add a new note </FormLabel> <FormDescription> Include a new note for this stock. This will not edit existing notes. </FormDescription> </div> </FormItem> )} /> {includeNewNote && ( <FormField control={form.control} name="noteContent" render={({ field }) => ( <FormItem> <FormLabel>New Note</FormLabel> <FormControl> <Textarea placeholder="Enter your new note here..." className="min-h-32" {...field} /> </FormControl> <FormMessage /> </FormItem> )} /> )} <DialogFooter> <Button type="button" variant="outline" onClick={() => onOpenChange(false)} disabled={isLoading} > Cancel </Button> <Button type="submit" disabled={isLoading || (sectorLoadError !== null && sectors.length === 0)}> {isLoading ? "Saving..." : "Save Changes"} </Button> </DialogFooter> </form> </Form> </DialogContent> </Dialog> ); }
```

# src/components/stocks/delete-stock-form.tsx

```tsx
"use client"; import { useState } from "react"; import { deleteStock } from "@/actions/stocks"; import { useToast } from "@/hooks/use-toast"; import { AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle, } from "@/components/ui/alert-dialog"; import { Button } from "@/components/ui/button"; interface Stock { id: string; ticker: string; name: string; transactions: number; } interface DeleteStockDialogProps { stock: Stock; open: boolean; onOpenChange: (open: boolean) => void; } export default function DeleteStockDialog({ stock, open, onOpenChange, }: DeleteStockDialogProps) { const { toast } = useToast(); const [isLoading, setIsLoading] = useState(false); const handleDelete = async () => { setIsLoading(true); try { const result = await deleteStock(stock.id); if (result.success) { toast({ title: "Stock deleted", description: `${stock.ticker} has been removed from your portfolio.`, }); onOpenChange(false); } else { toast({ title: "Error", description: result.error || "Failed to delete stock.", variant: "destructive", }); } } catch (error) { toast({ title: "Error", description: "An unexpected error occurred.", variant: "destructive", }); } finally { setIsLoading(false); } }; return ( <AlertDialog open={open} onOpenChange={onOpenChange}> <AlertDialogContent> <AlertDialogHeader> <AlertDialogTitle>Delete Stock</AlertDialogTitle> <AlertDialogDescription> Are you sure you want to delete {stock.ticker} ({stock.name}) from your portfolio? {stock.transactions > 0 && ( <p className="mt-2 text-destructive font-medium"> Warning: This stock has {stock.transactions} transactions. You need to delete all transactions before deleting the stock. </p> )} </AlertDialogDescription> </AlertDialogHeader> <AlertDialogFooter> <AlertDialogCancel disabled={isLoading}>Cancel</AlertDialogCancel> <Button variant="destructive" onClick={handleDelete} disabled={isLoading || stock.transactions > 0} > {isLoading ? "Deleting..." : "Delete"} </Button> </AlertDialogFooter> </AlertDialogContent> </AlertDialog> ); }
```

# src/components/stocks/delete-stock-dialog.tsx

```tsx
"use client"; import { useState } from "react"; import { deleteStock } from "@/actions/stocks"; import { useToast } from "@/hooks/use-toast"; import { AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle, } from "@/components/ui/alert-dialog"; import { Button } from "@/components/ui/button"; interface Stock { id: string; ticker: string; name: string; transactions: number; } interface DeleteStockDialogProps { stock: Stock; open: boolean; onOpenChange: (open: boolean) => void; } export default function DeleteStockDialog({ stock, open, onOpenChange, }: DeleteStockDialogProps) { const { toast } = useToast(); const [isLoading, setIsLoading] = useState(false); const handleDelete = async () => { setIsLoading(true); try { const result = await deleteStock(stock.id); if (result.success) { toast({ title: "Stock deleted", description: `${stock.ticker} has been removed from your portfolio.`, }); onOpenChange(false); } else { toast({ title: "Error", description: result.error || "Failed to delete stock.", variant: "destructive", }); } } catch (error) { toast({ title: "Error", description: "An unexpected error occurred.", variant: "destructive", }); } finally { setIsLoading(false); } }; return ( <AlertDialog open={open} onOpenChange={onOpenChange}> <AlertDialogContent> <AlertDialogHeader> <AlertDialogTitle>Delete Stock</AlertDialogTitle> <AlertDialogDescription> Are you sure you want to delete {stock.ticker} ({stock.name}) from your portfolio? {stock.transactions > 0 && ( <p className="mt-2 text-destructive font-medium"> Warning: This stock has {stock.transactions} transactions. You need to delete all transactions before deleting the stock. </p> )} </AlertDialogDescription> </AlertDialogHeader> <AlertDialogFooter> <AlertDialogCancel disabled={isLoading}>Cancel</AlertDialogCancel> <Button variant="destructive" onClick={handleDelete} disabled={isLoading || stock.transactions > 0} > {isLoading ? "Deleting..." : "Delete"} </Button> </AlertDialogFooter> </AlertDialogContent> </AlertDialog> ); }
```

# src/components/stocks/add-stock-form.tsx

```tsx
"use client"; import { useState, useEffect } from "react"; import { useForm } from "react-hook-form"; import { zodResolver } from "@hookform/resolvers/zod"; import { StockWithNoteFormValues, stockWithNoteSchema } from "@/lib/validators"; import { createStock, getSectors } from "@/actions/stocks"; import { createNote } from "@/actions/notes"; import { useToast } from "@/hooks/use-toast"; import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle, } from "@/components/ui/dialog"; import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage, FormDescription, } from "@/components/ui/form"; import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue, } from "@/components/ui/select"; import { Input } from "@/components/ui/input"; import { Button } from "@/components/ui/button"; import { Textarea } from "@/components/ui/textarea"; import { Checkbox } from "@/components/ui/checkbox"; import { getCurrencySymbol } from "@/lib/utils"; import { getCurrentUser } from "@/actions/user"; interface AddStockFormProps { open: boolean; onOpenChange: (open: boolean) => void; } export default function AddStockForm({ open, onOpenChange }: AddStockFormProps) { const { toast } = useToast(); const [isLoading, setIsLoading] = useState(false); const [sectors, setSectors] = useState<{ id: string; name: string }[]>([]); const [includeNote, setIncludeNote] = useState(false); const [sectorLoadError, setSectorLoadError] = useState<string | null>(null); // State for sector loading errors const [userDefaultCurrency, setUserDefaultCurrency] = useState<string>("GBP"); const form = useForm<StockWithNoteFormValues>({ resolver: zodResolver(stockWithNoteSchema), defaultValues: { ticker: "", name: "", sectorId: "none", currency: "USD", // Default to USD for stocks includeNote: false, noteContent: "", }, }); // Get user's default currency useEffect(() => { const fetchUserCurrency = async () => { try { const user = await getCurrentUser(); setUserDefaultCurrency(user.defaultCurrency || "GBP"); } catch (error) { console.error("Error fetching user currency:", error); } }; if (open) { fetchUserCurrency(); } }, [open]); // Load sectors when dialog opens useEffect(() => { const loadSectors = async () => { if (open && sectors.length === 0) { const { success, data, error } = await getSectors(); if (success && data) { setSectors(data); setSectorLoadError(null); // Clear any previous error } else { console.error("Error loading sectors:", error); setSectorLoadError(error || "Failed to load sectors."); toast({ title: "Error loading sectors", description: error || "Failed to load sectors.", variant: "destructive", }); } } }; loadSectors(); }, [open, sectors.length, toast]); // Reset form when dialog closes useEffect(() => { if (!open) { form.reset({ ticker: "", name: "", sectorId: "none", currency: "USD", // Default to USD for stocks includeNote: false, noteContent: "", }); setIncludeNote(false); setSectorLoadError(null); // Clear error on close } }, [open, form]); // Handle the include note checkbox const handleIncludeNoteChange = (checked: boolean) => { setIncludeNote(checked); form.setValue("includeNote", checked); }; const onSubmit = async (data: StockWithNoteFormValues) => { setIsLoading(true); try { const result = await createStock({ ticker: data.ticker, name: data.name, sectorId: data.sectorId, currency: data.currency, }); if (result.success) { if (data.includeNote && data.noteContent && result.data) { await createNote({ content: data.noteContent, stockId: result.data.id, }); } const currencySymbol = getCurrencySymbol(data.currency); toast({ title: "Stock added", description: `${data.ticker} has been added to your portfolio (${currencySymbol} ${data.currency}).`, }); form.reset({ ticker: "", name: "", sectorId: "none", currency: "USD", includeNote: false, noteContent: "", }); setIncludeNote(false); onOpenChange(false); } else { toast({ title: "Error", description: result.error || "Failed to add stock.", variant: "destructive", }); } } catch (error) { toast({ title: "Error", description: "An unexpected error occurred.", variant: "destructive", }); } finally { setIsLoading(false); } }; return ( <Dialog open={open} onOpenChange={onOpenChange}> <DialogContent className="max-h-[90vh] overflow-y-auto"> <DialogHeader> <DialogTitle>Add Stock</DialogTitle> <DialogDescription> Add a new stock to your portfolio </DialogDescription> </DialogHeader> <Form {...form}> <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4"> <FormField control={form.control} name="ticker" render={({ field }) => ( <FormItem> <FormLabel>Ticker Symbol</FormLabel> <FormControl> <Input placeholder="AAPL" {...field} value={field.value} onChange={(e) => field.onChange(e.target.value.toUpperCase())} /> </FormControl> <FormMessage /> </FormItem> )} /> <FormField control={form.control} name="name" render={({ field }) => ( <FormItem> <FormLabel>Company Name</FormLabel> <FormControl> <Input placeholder="Apple Inc." {...field} /> </FormControl> <FormMessage /> </FormItem> )} /> <FormField control={form.control} name="currency" render={({ field }) => ( <FormItem> <FormLabel>Currency</FormLabel> <Select onValueChange={field.onChange} defaultValue={field.value} > <FormControl> <SelectTrigger> <SelectValue placeholder="Select a currency" /> </SelectTrigger> </FormControl> <SelectContent> <SelectItem value="USD">{getCurrencySymbol("USD")} USD - US Dollar</SelectItem> <SelectItem value="GBP">{getCurrencySymbol("GBP")} GBP - British Pound</SelectItem> <SelectItem value="EUR">{getCurrencySymbol("EUR")} EUR - Euro</SelectItem> <SelectItem value="JPY">{getCurrencySymbol("JPY")} JPY - Japanese Yen</SelectItem> <SelectItem value="CHF">{getCurrencySymbol("CHF")} CHF - Swiss Franc</SelectItem> <SelectItem value="CAD">{getCurrencySymbol("CAD")} CAD - Canadian Dollar</SelectItem> <SelectItem value="AUD">{getCurrencySymbol("AUD")} AUD - Australian Dollar</SelectItem> </SelectContent> </Select> <FormDescription> {field.value !== userDefaultCurrency ? `This differs from your default currency (${getCurrencySymbol(userDefaultCurrency)} ${userDefaultCurrency}). Exchange rates will be needed for transactions.` : `This matches your default currency (${getCurrencySymbol(userDefaultCurrency)} ${userDefaultCurrency}).` } </FormDescription> <FormMessage /> </FormItem> )} /> <FormField control={form.control} name="sectorId" render={({ field }) => ( <FormItem> <FormLabel>Sector</FormLabel> <Select onValueChange={field.onChange} value={field.value || "none"} disabled={sectorLoadError !== null && sectors.length === 0} // Disable if loading failed and no sectors > <FormControl> <SelectTrigger> <SelectValue placeholder={sectorLoadError || "Select a sector"} /> </SelectTrigger> </FormControl> <SelectContent> <SelectItem value="none">None</SelectItem> {sectors.map((sector) => ( <SelectItem key={sector.id} value={sector.id}> {sector.name} </SelectItem> ))} </SelectContent> </Select> <FormMessage /> {sectorLoadError && ( <FormMessage className="text-destructive"> {sectorLoadError} </FormMessage> )} </FormItem> )} /> <FormField control={form.control} name="includeNote" render={({ field }) => ( <FormItem className="flex flex-row items-start space-x-3 space-y-0 rounded-md border p-4"> <FormControl> <Checkbox checked={field.value} onCheckedChange={(checked) => { field.onChange(checked); handleIncludeNoteChange(checked === true); }} /> </FormControl> <div className="space-y-1 leading-none"> <FormLabel> Add a note to this stock </FormLabel> <FormDescription> Include notes about this stock, investment thesis, or research </FormDescription> </div> </FormItem> )} /> {includeNote && ( <FormField control={form.control} name="noteContent" render={({ field }) => ( <FormItem> <FormLabel>Note</FormLabel> <FormControl> <Textarea placeholder="Enter your note here..." className="min-h-32" {...field} /> </FormControl> <FormMessage /> </FormItem> )} /> )} <DialogFooter> <Button type="button" variant="outline" onClick={() => onOpenChange(false)} disabled={isLoading} > Cancel </Button> <Button type="submit" disabled={isLoading || sectorLoadError !== null && sectors.length === 0}> {isLoading ? "Adding..." : "Add Stock"} </Button> </DialogFooter> </form> </Form> </DialogContent> </Dialog> ); }
```

# src/components/ui/toaster.tsx

```tsx
"use client" import { Toast, ToastClose, ToastDescription, ToastProvider, ToastTitle, ToastViewport, } from "@/components/ui/toast" import { useToast } from "@/hooks/use-toast" export function Toaster() { const { toasts } = useToast() return ( <ToastProvider> {toasts.map(function ({ id, title, description, action, ...props }) { return ( <Toast key={id} {...props}> <div className="grid gap-1"> {title && <ToastTitle>{title}</ToastTitle>} {description && ( <ToastDescription>{description}</ToastDescription> )} </div> {action} <ToastClose /> </Toast> ) })} <ToastViewport /> </ToastProvider> ) }
```

# src/components/ui/toast.tsx

```tsx
import * as React from "react" import * as ToastPrimitives from "@radix-ui/react-toast" import { cva, type VariantProps } from "class-variance-authority" import { X } from "lucide-react" import { cn } from "@/lib/utils" const ToastProvider = ToastPrimitives.Provider const ToastViewport = React.forwardRef< React.ElementRef<typeof ToastPrimitives.Viewport>, React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport> >(({ className, ...props }, ref) => ( <ToastPrimitives.Viewport ref={ref} className={cn( "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]", className )} {...props} /> )) ToastViewport.displayName = ToastPrimitives.Viewport.displayName const toastVariants = cva( "group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full", { variants: { variant: { default: "border bg-background text-foreground", destructive: "destructive group border-destructive bg-destructive text-destructive-foreground", }, }, defaultVariants: { variant: "default", }, } ) const Toast = React.forwardRef< React.ElementRef<typeof ToastPrimitives.Root>, React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> & VariantProps<typeof toastVariants> >(({ className, variant, ...props }, ref) => { return ( <ToastPrimitives.Root ref={ref} className={cn(toastVariants({ variant }), className)} {...props} /> ) }) Toast.displayName = ToastPrimitives.Root.displayName const ToastAction = React.forwardRef< React.ElementRef<typeof ToastPrimitives.Action>, React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action> >(({ className, ...props }, ref) => ( <ToastPrimitives.Action ref={ref} className={cn( "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive", className )} {...props} /> )) ToastAction.displayName = ToastPrimitives.Action.displayName const ToastClose = React.forwardRef< React.ElementRef<typeof ToastPrimitives.Close>, React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close> >(({ className, ...props }, ref) => ( <ToastPrimitives.Close ref={ref} className={cn( "absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600", className )} toast-close="" {...props} > <X className="h-4 w-4" /> </ToastPrimitives.Close> )) ToastClose.displayName = ToastPrimitives.Close.displayName const ToastTitle = React.forwardRef< React.ElementRef<typeof ToastPrimitives.Title>, React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title> >(({ className, ...props }, ref) => ( <ToastPrimitives.Title ref={ref} className={cn("text-sm font-semibold", className)} {...props} /> )) ToastTitle.displayName = ToastPrimitives.Title.displayName const ToastDescription = React.forwardRef< React.ElementRef<typeof ToastPrimitives.Description>, React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description> >(({ className, ...props }, ref) => ( <ToastPrimitives.Description ref={ref} className={cn("text-sm opacity-90", className)} {...props} /> )) ToastDescription.displayName = ToastPrimitives.Description.displayName type ToastProps = React.ComponentPropsWithoutRef<typeof Toast> type ToastActionElement = React.ReactElement<typeof ToastAction> export { type ToastProps, type ToastActionElement, ToastProvider, ToastViewport, Toast, ToastTitle, ToastDescription, ToastClose, ToastAction, }
```

# src/components/ui/textarea.tsx

```tsx
import * as React from "react" import { cn } from "@/lib/utils" export interface TextareaProps extends React.TextareaHTMLAttributes<HTMLTextAreaElement> { } const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>( ({ className, ...props }, ref) => { return ( <textarea className={cn( "flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50", className )} ref={ref} {...props} /> ) } ) Textarea.displayName = "Textarea" export { Textarea }
```

# src/components/ui/select.tsx

```tsx
"use client" import * as React from "react" import * as SelectPrimitive from "@radix-ui/react-select" import { Check, ChevronDown, ChevronUp } from "lucide-react" import { cn } from "@/lib/utils" const Select = SelectPrimitive.Root const SelectGroup = SelectPrimitive.Group const SelectValue = SelectPrimitive.Value const SelectTrigger = React.forwardRef< React.ElementRef<typeof SelectPrimitive.Trigger>, React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger> >(({ className, children, ...props }, ref) => ( <SelectPrimitive.Trigger ref={ref} className={cn( "flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1", className )} {...props} > {children} <SelectPrimitive.Icon asChild> <ChevronDown className="h-4 w-4 opacity-50" /> </SelectPrimitive.Icon> </SelectPrimitive.Trigger> )) SelectTrigger.displayName = SelectPrimitive.Trigger.displayName const SelectScrollUpButton = React.forwardRef< React.ElementRef<typeof SelectPrimitive.ScrollUpButton>, React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton> >(({ className, ...props }, ref) => ( <SelectPrimitive.ScrollUpButton ref={ref} className={cn( "flex cursor-default items-center justify-center py-1", className )} {...props} > <ChevronUp className="h-4 w-4" /> </SelectPrimitive.ScrollUpButton> )) SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName const SelectScrollDownButton = React.forwardRef< React.ElementRef<typeof SelectPrimitive.ScrollDownButton>, React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton> >(({ className, ...props }, ref) => ( <SelectPrimitive.ScrollDownButton ref={ref} className={cn( "flex cursor-default items-center justify-center py-1", className )} {...props} > <ChevronDown className="h-4 w-4" /> </SelectPrimitive.ScrollDownButton> )) SelectScrollDownButton.displayName = SelectPrimitive.ScrollDownButton.displayName const SelectContent = React.forwardRef< React.ElementRef<typeof SelectPrimitive.Content>, React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content> >(({ className, children, position = "popper", ...props }, ref) => ( <SelectPrimitive.Portal> <SelectPrimitive.Content ref={ref} className={cn( "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2", position === "popper" && "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1", className )} position={position} {...props} > <SelectScrollUpButton /> <SelectPrimitive.Viewport className={cn( "p-1", position === "popper" && "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]" )} > {children} </SelectPrimitive.Viewport> <SelectScrollDownButton /> </SelectPrimitive.Content> </SelectPrimitive.Portal> )) SelectContent.displayName = SelectPrimitive.Content.displayName const SelectLabel = React.forwardRef< React.ElementRef<typeof SelectPrimitive.Label>, React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label> >(({ className, ...props }, ref) => ( <SelectPrimitive.Label ref={ref} className={cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className)} {...props} /> )) SelectLabel.displayName = SelectPrimitive.Label.displayName const SelectItem = React.forwardRef< React.ElementRef<typeof SelectPrimitive.Item>, React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item> >(({ className, children, ...props }, ref) => ( <SelectPrimitive.Item ref={ref} className={cn( "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50", className )} {...props} > <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center"> <SelectPrimitive.ItemIndicator> <Check className="h-4 w-4" /> </SelectPrimitive.ItemIndicator> </span> <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText> </SelectPrimitive.Item> )) SelectItem.displayName = SelectPrimitive.Item.displayName const SelectSeparator = React.forwardRef< React.ElementRef<typeof SelectPrimitive.Separator>, React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator> >(({ className, ...props }, ref) => ( <SelectPrimitive.Separator ref={ref} className={cn("-mx-1 my-1 h-px bg-muted", className)} {...props} /> )) SelectSeparator.displayName = SelectPrimitive.Separator.displayName export { Select, SelectGroup, SelectValue, SelectTrigger, SelectContent, SelectLabel, SelectItem, SelectSeparator, SelectScrollUpButton, SelectScrollDownButton, }
```

# src/components/ui/popover.tsx

```tsx
"use client" import * as React from "react" import * as PopoverPrimitive from "@radix-ui/react-popover" import { cn } from "@/lib/utils" const Popover = PopoverPrimitive.Root const PopoverTrigger = PopoverPrimitive.Trigger const PopoverContent = React.forwardRef< React.ElementRef<typeof PopoverPrimitive.Content>, React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content> >(({ className, align = "center", sideOffset = 4, ...props }, ref) => ( <PopoverPrimitive.Portal> <PopoverPrimitive.Content ref={ref} align={align} sideOffset={sideOffset} className={cn( "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2", className )} {...props} /> </PopoverPrimitive.Portal> )) PopoverContent.displayName = PopoverPrimitive.Content.displayName export { Popover, PopoverTrigger, PopoverContent }
```

# src/components/ui/mode-toggle.tsx

```tsx
"use client"; import * as React from "react"; import { Moon, Sun } from "lucide-react"; import { useTheme } from "next-themes"; import { Button } from "@/components/ui/button"; import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger, } from "@/components/ui/dropdown-menu"; export function ModeToggle() { const { setTheme } = useTheme(); return ( <DropdownMenu> <DropdownMenuTrigger asChild> <Button variant="outline" size="icon"> <Sun className="h-[1.2rem] w-[1.2rem] rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0" /> <Moon className="absolute h-[1.2rem] w-[1.2rem] rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100" /> <span className="sr-only">Toggle theme</span> </Button> </DropdownMenuTrigger> <DropdownMenuContent align="end"> <DropdownMenuItem onClick={() => setTheme("light")}> Light </DropdownMenuItem> <DropdownMenuItem onClick={() => setTheme("dark")}> Dark </DropdownMenuItem> <DropdownMenuItem onClick={() => setTheme("system")}> System </DropdownMenuItem> </DropdownMenuContent> </DropdownMenu> ); }
```

# src/components/ui/label.tsx

```tsx
"use client" import * as React from "react" import * as LabelPrimitive from "@radix-ui/react-label" import { cva, type VariantProps } from "class-variance-authority" import { cn } from "@/lib/utils" const labelVariants = cva( "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70" ) const Label = React.forwardRef< React.ElementRef<typeof LabelPrimitive.Root>, React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> & VariantProps<typeof labelVariants> >(({ className, ...props }, ref) => ( <LabelPrimitive.Root ref={ref} className={cn(labelVariants(), className)} {...props} /> )) Label.displayName = LabelPrimitive.Root.displayName export { Label }
```

# src/components/ui/input.tsx

```tsx
import * as React from "react" import { cn } from "@/lib/utils" export interface InputProps extends React.InputHTMLAttributes<HTMLInputElement> { } const Input = React.forwardRef<HTMLInputElement, InputProps>( ({ className, type, ...props }, ref) => { return ( <input type={type} className={cn( "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50", className )} ref={ref} {...props} /> ) } ) Input.displayName = "Input" export { Input }
```

# src/components/ui/form.tsx

```tsx
import * as React from "react" import * as LabelPrimitive from "@radix-ui/react-label" import { Slot } from "@radix-ui/react-slot" import { Controller, ControllerProps, FieldPath, FieldValues, FormProvider, useFormContext, } from "react-hook-form" import { cn } from "@/lib/utils" import { Label } from "@/components/ui/label" const Form = FormProvider type FormFieldContextValue< TFieldValues extends FieldValues = FieldValues, TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues> > = { name: TName } const FormFieldContext = React.createContext<FormFieldContextValue>( {} as FormFieldContextValue ) const FormField = < TFieldValues extends FieldValues = FieldValues, TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues> >({ ...props }: ControllerProps<TFieldValues, TName>) => { return ( <FormFieldContext.Provider value={{ name: props.name }}> <Controller {...props} /> </FormFieldContext.Provider> ) } const useFormField = () => { const fieldContext = React.useContext(FormFieldContext) const itemContext = React.useContext(FormItemContext) const { getFieldState, formState } = useFormContext() const fieldState = getFieldState(fieldContext.name, formState) if (!fieldContext) { throw new Error("useFormField should be used within <FormField>") } const { id } = itemContext return { id, name: fieldContext.name, formItemId: `${id}-form-item`, formDescriptionId: `${id}-form-item-description`, formMessageId: `${id}-form-item-message`, ...fieldState, } } type FormItemContextValue = { id: string } const FormItemContext = React.createContext<FormItemContextValue>( {} as FormItemContextValue ) const FormItem = React.forwardRef< HTMLDivElement, React.HTMLAttributes<HTMLDivElement> >(({ className, ...props }, ref) => { const id = React.useId() return ( <FormItemContext.Provider value={{ id }}> <div ref={ref} className={cn("space-y-2", className)} {...props} /> </FormItemContext.Provider> ) }) FormItem.displayName = "FormItem" const FormLabel = React.forwardRef< React.ElementRef<typeof LabelPrimitive.Root>, React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> >(({ className, ...props }, ref) => { const { error, formItemId } = useFormField() return ( <Label ref={ref} className={cn(error && "text-destructive", className)} htmlFor={formItemId} {...props} /> ) }) FormLabel.displayName = "FormLabel" const FormControl = React.forwardRef< React.ElementRef<typeof Slot>, React.ComponentPropsWithoutRef<typeof Slot> >(({ ...props }, ref) => { const { error, formItemId, formDescriptionId, formMessageId } = useFormField() return ( <Slot ref={ref} id={formItemId} aria-describedby={ !error ? `${formDescriptionId}` : `${formDescriptionId} ${formMessageId}` } aria-invalid={!!error} {...props} /> ) }) FormControl.displayName = "FormControl" const FormDescription = React.forwardRef< HTMLParagraphElement, React.HTMLAttributes<HTMLParagraphElement> >(({ className, ...props }, ref) => { const { formDescriptionId } = useFormField() return ( <p ref={ref} id={formDescriptionId} className={cn("text-sm text-muted-foreground", className)} {...props} /> ) }) FormDescription.displayName = "FormDescription" const FormMessage = React.forwardRef< HTMLParagraphElement, React.HTMLAttributes<HTMLParagraphElement> >(({ className, children, ...props }, ref) => { const { error, formMessageId } = useFormField() const body = error ? String(error?.message) : children if (!body) { return null } return ( <p ref={ref} id={formMessageId} className={cn("text-sm font-medium text-destructive", className)} {...props} > {body} </p> ) }) FormMessage.displayName = "FormMessage" export { useFormField, Form, FormItem, FormLabel, FormControl, FormDescription, FormMessage, FormField, }
```

# src/components/ui/dropdown-menu.tsx

```tsx
"use client" import * as React from "react" import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu" import { Check, ChevronRight, Circle } from "lucide-react" import { cn } from "@/lib/utils" const DropdownMenu = DropdownMenuPrimitive.Root const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger const DropdownMenuGroup = DropdownMenuPrimitive.Group const DropdownMenuPortal = DropdownMenuPrimitive.Portal const DropdownMenuSub = DropdownMenuPrimitive.Sub const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup const DropdownMenuSubTrigger = React.forwardRef< React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>, React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & { inset?: boolean } >(({ className, inset, children, ...props }, ref) => ( <DropdownMenuPrimitive.SubTrigger ref={ref} className={cn( "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent", inset && "pl-8", className )} {...props} > {children} <ChevronRight className="ml-auto h-4 w-4" /> </DropdownMenuPrimitive.SubTrigger> )) DropdownMenuSubTrigger.displayName = DropdownMenuPrimitive.SubTrigger.displayName const DropdownMenuSubContent = React.forwardRef< React.ElementRef<typeof DropdownMenuPrimitive.SubContent>, React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent> >(({ className, ...props }, ref) => ( <DropdownMenuPrimitive.SubContent ref={ref} className={cn( "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2", className )} {...props} /> )) DropdownMenuSubContent.displayName = DropdownMenuPrimitive.SubContent.displayName const DropdownMenuContent = React.forwardRef< React.ElementRef<typeof DropdownMenuPrimitive.Content>, React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content> >(({ className, sideOffset = 4, ...props }, ref) => ( <DropdownMenuPrimitive.Portal> <DropdownMenuPrimitive.Content ref={ref} sideOffset={sideOffset} className={cn( "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2", className )} {...props} /> </DropdownMenuPrimitive.Portal> )) DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName const DropdownMenuItem = React.forwardRef< React.ElementRef<typeof DropdownMenuPrimitive.Item>, React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & { inset?: boolean } >(({ className, inset, ...props }, ref) => ( <DropdownMenuPrimitive.Item ref={ref} className={cn( "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50", inset && "pl-8", className )} {...props} /> )) DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName const DropdownMenuCheckboxItem = React.forwardRef< React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>, React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem> >(({ className, children, checked, ...props }, ref) => ( <DropdownMenuPrimitive.CheckboxItem ref={ref} className={cn( "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50", className )} checked={checked} {...props} > <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center"> <DropdownMenuPrimitive.ItemIndicator> <Check className="h-4 w-4" /> </DropdownMenuPrimitive.ItemIndicator> </span> {children} </DropdownMenuPrimitive.CheckboxItem> )) DropdownMenuCheckboxItem.displayName = DropdownMenuPrimitive.CheckboxItem.displayName const DropdownMenuRadioItem = React.forwardRef< React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>, React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem> >(({ className, children, ...props }, ref) => ( <DropdownMenuPrimitive.RadioItem ref={ref} className={cn( "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50", className )} {...props} > <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center"> <DropdownMenuPrimitive.ItemIndicator> <Circle className="h-2 w-2 fill-current" /> </DropdownMenuPrimitive.ItemIndicator> </span> {children} </DropdownMenuPrimitive.RadioItem> )) DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName const DropdownMenuLabel = React.forwardRef< React.ElementRef<typeof DropdownMenuPrimitive.Label>, React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & { inset?: boolean } >(({ className, inset, ...props }, ref) => ( <DropdownMenuPrimitive.Label ref={ref} className={cn( "px-2 py-1.5 text-sm font-semibold", inset && "pl-8", className )} {...props} /> )) DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName const DropdownMenuSeparator = React.forwardRef< React.ElementRef<typeof DropdownMenuPrimitive.Separator>, React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator> >(({ className, ...props }, ref) => ( <DropdownMenuPrimitive.Separator ref={ref} className={cn("-mx-1 my-1 h-px bg-muted", className)} {...props} /> )) DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName const DropdownMenuShortcut = ({ className, ...props }: React.HTMLAttributes<HTMLSpanElement>) => { return ( <span className={cn("ml-auto text-xs tracking-widest opacity-60", className)} {...props} /> ) } DropdownMenuShortcut.displayName = "DropdownMenuShortcut" export { DropdownMenu, DropdownMenuTrigger, DropdownMenuContent, DropdownMenuItem, DropdownMenuCheckboxItem, DropdownMenuRadioItem, DropdownMenuLabel, DropdownMenuSeparator, DropdownMenuShortcut, DropdownMenuGroup, DropdownMenuPortal, DropdownMenuSub, DropdownMenuSubContent, DropdownMenuSubTrigger, DropdownMenuRadioGroup, }
```

# src/components/ui/dialog.tsx

```tsx
"use client" import * as React from "react" import * as DialogPrimitive from "@radix-ui/react-dialog" import { X } from "lucide-react" import { cn } from "@/lib/utils" const Dialog = DialogPrimitive.Root const DialogTrigger = DialogPrimitive.Trigger const DialogPortal = DialogPrimitive.Portal const DialogClose = DialogPrimitive.Close const DialogOverlay = React.forwardRef< React.ElementRef<typeof DialogPrimitive.Overlay>, React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay> >(({ className, ...props }, ref) => ( <DialogPrimitive.Overlay ref={ref} className={cn( "fixed inset-0 z-50 bg-black/80 backdrop-blur-sm data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0", className )} {...props} /> )) DialogOverlay.displayName = DialogPrimitive.Overlay.displayName const DialogContent = React.forwardRef< React.ElementRef<typeof DialogPrimitive.Content>, React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content> >(({ className, children, ...props }, ref) => ( <DialogPortal> <DialogOverlay /> <DialogPrimitive.Content ref={ref} className={cn( "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg", className )} {...props} > {children} <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground"> <X className="h-4 w-4" /> <span className="sr-only">Close</span> </DialogPrimitive.Close> </DialogPrimitive.Content> </DialogPortal> )) DialogContent.displayName = DialogPrimitive.Content.displayName const DialogHeader = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => ( <div className={cn( "flex flex-col space-y-1.5 text-center sm:text-left", className )} {...props} /> ) DialogHeader.displayName = "DialogHeader" const DialogFooter = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => ( <div className={cn( "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2", className )} {...props} /> ) DialogFooter.displayName = "DialogFooter" const DialogTitle = React.forwardRef< React.ElementRef<typeof DialogPrimitive.Title>, React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title> >(({ className, ...props }, ref) => ( <DialogPrimitive.Title ref={ref} className={cn( "text-lg font-semibold leading-none tracking-tight", className )} {...props} /> )) DialogTitle.displayName = DialogPrimitive.Title.displayName const DialogDescription = React.forwardRef< React.ElementRef<typeof DialogPrimitive.Description>, React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description> >(({ className, ...props }, ref) => ( <DialogPrimitive.Description ref={ref} className={cn("text-sm text-muted-foreground", className)} {...props} /> )) DialogDescription.displayName = DialogPrimitive.Description.displayName export { Dialog, DialogPortal, DialogOverlay, DialogClose, DialogTrigger, DialogContent, DialogHeader, DialogFooter, DialogTitle, DialogDescription, }
```

# src/components/ui/checkbox.tsx

```tsx
"use client" import * as React from "react" import * as CheckboxPrimitive from "@radix-ui/react-checkbox" import { Check } from "lucide-react" import { cn } from "@/lib/utils" const Checkbox = React.forwardRef< React.ElementRef<typeof CheckboxPrimitive.Root>, React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root> >(({ className, ...props }, ref) => ( <CheckboxPrimitive.Root ref={ref} className={cn( "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground", className )} {...props} > <CheckboxPrimitive.Indicator className={cn("flex items-center justify-center text-current")} > <Check className="h-4 w-4" /> </CheckboxPrimitive.Indicator> </CheckboxPrimitive.Root> )) Checkbox.displayName = CheckboxPrimitive.Root.displayName export { Checkbox }
```

# src/components/ui/card.tsx

```tsx
import * as React from "react" import { cn } from "@/lib/utils" const Card = React.forwardRef< HTMLDivElement, React.HTMLAttributes<HTMLDivElement> >(({ className, ...props }, ref) => ( <div ref={ref} className={cn( "rounded-lg border bg-card text-card-foreground shadow-sm", className )} {...props} /> )) Card.displayName = "Card" const CardHeader = React.forwardRef< HTMLDivElement, React.HTMLAttributes<HTMLDivElement> >(({ className, ...props }, ref) => ( <div ref={ref} className={cn("flex flex-col space-y-1.5 p-6", className)} {...props} /> )) CardHeader.displayName = "CardHeader" const CardTitle = React.forwardRef< HTMLParagraphElement, React.HTMLAttributes<HTMLHeadingElement> >(({ className, ...props }, ref) => ( <h3 ref={ref} className={cn( "text-2xl font-semibold leading-none tracking-tight", className )} {...props} /> )) CardTitle.displayName = "CardTitle" const CardDescription = React.forwardRef< HTMLParagraphElement, React.HTMLAttributes<HTMLParagraphElement> >(({ className, ...props }, ref) => ( <p ref={ref} className={cn("text-sm text-muted-foreground", className)} {...props} /> )) CardDescription.displayName = "CardDescription" const CardContent = React.forwardRef< HTMLDivElement, React.HTMLAttributes<HTMLDivElement> >(({ className, ...props }, ref) => ( <div ref={ref} className={cn("p-6 pt-0", className)} {...props} /> )) CardContent.displayName = "CardContent" const CardFooter = React.forwardRef< HTMLDivElement, React.HTMLAttributes<HTMLDivElement> >(({ className, ...props }, ref) => ( <div ref={ref} className={cn("flex items-center p-6 pt-0", className)} {...props} /> )) CardFooter.displayName = "CardFooter" export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }
```

# src/components/ui/calendar.tsx

```tsx
"use client" import * as React from "react" import { ChevronLeft, ChevronRight } from "lucide-react" import { DayPicker } from "react-day-picker" import { cn } from "@/lib/utils" import { buttonVariants } from "@/components/ui/button" export type CalendarProps = React.ComponentProps<typeof DayPicker> function Calendar({ className, classNames, showOutsideDays = true, ...props }: CalendarProps) { return ( <DayPicker showOutsideDays={showOutsideDays} className={cn("p-3", className)} classNames={{ months: "flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0", month: "space-y-4", caption: "flex justify-center pt-1 relative items-center", caption_label: "text-sm font-medium", nav: "space-x-1 flex items-center", nav_button: cn( buttonVariants({ variant: "outline" }), "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100" ), nav_button_previous: "absolute left-1", nav_button_next: "absolute right-1", table: "w-full border-collapse space-y-1", head_row: "flex", head_cell: "text-muted-foreground rounded-md w-9 font-normal text-[0.8rem]", row: "flex w-full mt-2", cell: "h-9 w-9 text-center text-sm p-0 relative [&:has([aria-selected].day-range-end)]:rounded-r-md [&:has([aria-selected].day-outside)]:bg-accent/50 [&:has([aria-selected])]:bg-accent first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md focus-within:relative focus-within:z-20", day: cn( buttonVariants({ variant: "ghost" }), "h-9 w-9 p-0 font-normal aria-selected:opacity-100" ), day_range_end: "day-range-end", day_selected: "bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground", day_today: "bg-accent text-accent-foreground", day_outside: "day-outside text-muted-foreground opacity-50 aria-selected:bg-accent/50 aria-selected:text-muted-foreground aria-selected:opacity-30", day_disabled: "text-muted-foreground opacity-50", day_range_middle: "aria-selected:bg-accent aria-selected:text-accent-foreground", day_hidden: "invisible", ...classNames, }} components={{ IconLeft: ({ ...props }) => <ChevronLeft className="h-4 w-4" />, IconRight: ({ ...props }) => <ChevronRight className="h-4 w-4" />, }} {...props} /> ) } Calendar.displayName = "Calendar" export { Calendar }
```

# src/components/ui/button.tsx

```tsx
import * as React from "react" import { Slot } from "@radix-ui/react-slot" import { cva, type VariantProps } from "class-variance-authority" import { cn } from "@/lib/utils" const buttonVariants = cva( "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50", { variants: { variant: { default: "bg-primary text-primary-foreground hover:bg-primary/90", destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90", outline: "border border-input bg-background hover:bg-accent hover:text-accent-foreground", secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80", ghost: "hover:bg-accent hover:text-accent-foreground", link: "text-primary underline-offset-4 hover:underline", }, size: { default: "h-10 px-4 py-2", sm: "h-9 rounded-md px-3", lg: "h-11 rounded-md px-8", icon: "h-10 w-10", }, }, defaultVariants: { variant: "default", size: "default", }, } ) export interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement>, VariantProps<typeof buttonVariants> { asChild?: boolean } const Button = React.forwardRef<HTMLButtonElement, ButtonProps>( ({ className, variant, size, asChild = false, ...props }, ref) => { const Comp = asChild ? Slot : "button" return ( <Comp className={cn(buttonVariants({ variant, size, className }))} ref={ref} {...props} /> ) } ) Button.displayName = "Button" export { Button, buttonVariants }
```

# src/components/ui/alert-dialog.tsx

```tsx
"use client" import * as React from "react" import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog" import { cn } from "@/lib/utils" import { buttonVariants } from "@/components/ui/button" const AlertDialog = AlertDialogPrimitive.Root const AlertDialogTrigger = AlertDialogPrimitive.Trigger const AlertDialogPortal = AlertDialogPrimitive.Portal const AlertDialogOverlay = React.forwardRef< React.ElementRef<typeof AlertDialogPrimitive.Overlay>, React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay> >(({ className, ...props }, ref) => ( <AlertDialogPrimitive.Overlay className={cn( "fixed inset-0 z-50 bg-black/80 backdrop-blur-sm data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0", className )} {...props} ref={ref} /> )) AlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName const AlertDialogContent = React.forwardRef< React.ElementRef<typeof AlertDialogPrimitive.Content>, React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content> >(({ className, ...props }, ref) => ( <AlertDialogPortal> <AlertDialogOverlay /> <AlertDialogPrimitive.Content ref={ref} className={cn( "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg", className )} {...props} /> </AlertDialogPortal> )) AlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName const AlertDialogHeader = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => ( <div className={cn( "flex flex-col space-y-2 text-center sm:text-left", className )} {...props} /> ) AlertDialogHeader.displayName = "AlertDialogHeader" const AlertDialogFooter = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => ( <div className={cn( "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2", className )} {...props} /> ) AlertDialogFooter.displayName = "AlertDialogFooter" const AlertDialogTitle = React.forwardRef< React.ElementRef<typeof AlertDialogPrimitive.Title>, React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title> >(({ className, ...props }, ref) => ( <AlertDialogPrimitive.Title ref={ref} className={cn("text-lg font-semibold", className)} {...props} /> )) AlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName const AlertDialogDescription = React.forwardRef< React.ElementRef<typeof AlertDialogPrimitive.Description>, React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description> >(({ className, ...props }, ref) => ( <AlertDialogPrimitive.Description ref={ref} className={cn("text-sm text-muted-foreground", className)} {...props} /> )) AlertDialogDescription.displayName = AlertDialogPrimitive.Description.displayName const AlertDialogAction = React.forwardRef< React.ElementRef<typeof AlertDialogPrimitive.Action>, React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action> >(({ className, ...props }, ref) => ( <AlertDialogPrimitive.Action ref={ref} className={cn(buttonVariants(), className)} {...props} /> )) AlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName const AlertDialogCancel = React.forwardRef< React.ElementRef<typeof AlertDialogPrimitive.Cancel>, React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel> >(({ className, ...props }, ref) => ( <AlertDialogPrimitive.Cancel ref={ref} className={cn( buttonVariants({ variant: "outline" }), "mt-2 sm:mt-0", className )} {...props} /> )) AlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName export { AlertDialog, AlertDialogPortal, AlertDialogOverlay, AlertDialogTrigger, AlertDialogContent, AlertDialogHeader, AlertDialogFooter, AlertDialogTitle, AlertDialogDescription, AlertDialogAction, AlertDialogCancel, }
```

# src/components/notes/notes-table.tsx

```tsx
"use client"; import { useState } from "react"; import Link from "next/link"; import { Card, CardContent } from "@/components/ui/card"; import { Input } from "@/components/ui/input"; import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger, } from "@/components/ui/dropdown-menu"; import { Button } from "@/components/ui/button"; import { MoreHorizontalIcon, PencilIcon, TrashIcon } from "lucide-react"; import { formatDate } from "@/lib/utils"; import EditNoteForm from "@/components/notes/edit-note-form"; import DeleteNoteDialog from "@/components/notes/delete-note-dialog"; interface Note { id: string; content: string; createdAt: Date; stock?: { id: string; ticker: string; name: string; } | null; transaction?: { id: string; stock: { ticker: string; }; } | null; } interface NotesTableProps { notes: Note[]; } export default function NotesTable({ notes }: NotesTableProps) { const [search, setSearch] = useState(""); const [noteToEdit, setNoteToEdit] = useState<Note | null>(null); const [noteToDelete, setNoteToDelete] = useState<Note | null>(null); // Apply search filter const filteredNotes = notes.filter((note) => { const searchLower = search.toLowerCase(); return ( note.content.toLowerCase().includes(searchLower) || note.stock?.ticker.toLowerCase().includes(searchLower) || note.stock?.name.toLowerCase().includes(searchLower) || note.transaction?.stock.ticker.toLowerCase().includes(searchLower) ); }); // Sort by date (latest first) const sortedNotes = [...filteredNotes].sort( (a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime() ); return ( <div> <div className="mb-4"> <Input placeholder="Search notes..." value={search} onChange={(e) => setSearch(e.target.value)} className="max-w-md" /> </div> <Card> <CardContent className="p-0"> {sortedNotes.length === 0 ? ( <div className="py-24 text-center text-muted-foreground"> {notes.length === 0 ? "No notes yet. Add your first note to get started." : "No notes match your search."} </div> ) : ( <div className="divide-y"> {sortedNotes.map((note) => ( <div key={note.id} className="p-4 sm:p-6 hover:bg-muted/50"> <div className="flex items-start justify-between mb-2"> <div className="space-y-1"> <div className="font-medium"> {note.stock ? ( <Link href={`/stocks/${note.stock.id}`} className="hover:underline"> {note.stock.ticker}: {note.stock.name} </Link> ) : note.transaction ? ( <Link href={`/transactions/${note.transaction.id}`} className="hover:underline"> Transaction for {note.transaction.stock.ticker} </Link> ) : ( "General Note" )} </div> <div className="text-xs text-muted-foreground"> {formatDate(note.createdAt)} </div> </div> <div className="flex items-center"> <Link href={`/notes/${note.id}`}> <Button variant="ghost" size="sm"> View </Button> </Link> <DropdownMenu> <DropdownMenuTrigger asChild> <Button variant="ghost" size="sm"> <MoreHorizontalIcon className="h-4 w-4" /> <span className="sr-only">Actions</span> </Button> </DropdownMenuTrigger> <DropdownMenuContent align="end"> <DropdownMenuItem onClick={() => setNoteToEdit(note)} className="cursor-pointer" > <PencilIcon className="mr-2 h-4 w-4" /> Edit </DropdownMenuItem> <DropdownMenuItem onClick={() => setNoteToDelete(note)} className="cursor-pointer text-destructive focus:text-destructive" > <TrashIcon className="mr-2 h-4 w-4" /> Delete </DropdownMenuItem> </DropdownMenuContent> </DropdownMenu> </div> </div> <div className="text-sm line-clamp-3 text-muted-foreground"> {note.content} </div> </div> ))} </div> )} </CardContent> </Card> {noteToEdit && ( <EditNoteForm note={noteToEdit} entityType={noteToEdit.stock ? "stock" : "transaction"} entityId={noteToEdit.stock?.id || noteToEdit.transaction?.id || ""} open={!!noteToEdit} onOpenChange={(open) => { if (!open) setNoteToEdit(null); }} /> )} {noteToDelete && ( <DeleteNoteDialog note={noteToDelete} open={!!noteToDelete} onOpenChange={(open) => { if (!open) setNoteToDelete(null); }} /> )} </div> ); }
```

# src/components/notes/notes-header.tsx

```tsx
"use client"; import { useState } from "react"; import { Button } from "@/components/ui/button"; import { PlusIcon } from "lucide-react"; import AddNoteForm from "@/components/notes/add-note-form"; export default function NotesHeader() { const [showAddForm, setShowAddForm] = useState(false); return ( <div className="flex flex-col gap-4 sm:flex-row sm:items-center sm:justify-between"> <div> <h2 className="text-2xl font-bold tracking-tight">Notes</h2> <p className="text-muted-foreground"> Manage your investment research and notes </p> </div> <Button onClick={() => setShowAddForm(true)} className="sm:w-auto w-full"> <PlusIcon className="mr-2 h-4 w-4" /> Add Note </Button> <AddNoteForm entityType="stock" entityId="" open={showAddForm} onOpenChange={setShowAddForm} /> </div> ); }
```

# src/components/notes/note-actions.tsx

```tsx
"use client"; import { useState } from "react"; import { useRouter } from "next/navigation"; import { Button } from "@/components/ui/button"; import { PencilIcon, TrashIcon } from "lucide-react"; import EditNoteForm from "@/components/notes/edit-note-form"; import DeleteNoteDialog from "@/components/notes/delete-note-dialog"; interface Note { id: string; content: string; stockId?: string | null; transactionId?: string | null; stock?: { id: string; } | null; transaction?: { id: string; } | null; } interface NoteActionsProps { note: Note; } export default function NoteActions({ note }: NoteActionsProps) { const router = useRouter(); const [showEditForm, setShowEditForm] = useState(false); const [showDeleteDialog, setShowDeleteDialog] = useState(false); const entityType = note.stock ? "stock" : note.transaction ? "transaction" : "stock"; const entityId = note.stock?.id || note.transaction?.id || note.stockId || note.transactionId || ""; return ( <div className="flex gap-2"> <Button variant="outline" size="sm" onClick={() => setShowEditForm(true)} > <PencilIcon className="h-4 w-4 mr-2" /> Edit </Button> <Button variant="outline" size="sm" className="text-destructive hover:text-destructive" onClick={() => setShowDeleteDialog(true)} > <TrashIcon className="h-4 w-4 mr-2" /> Delete </Button> <EditNoteForm note={note} entityType={entityType} entityId={entityId} open={showEditForm} onOpenChange={setShowEditForm} /> <DeleteNoteDialog note={note} open={showDeleteDialog} onOpenChange={(open) => { if (!open) { setShowDeleteDialog(false); } else if (!open && !note.id) { // If deleted successfully, redirect to notes list router.push("/notes"); } }} /> </div> ); }
```

# src/components/notes/edit-note-form.tsx

```tsx
"use client"; import { useState, useEffect } from "react"; import { useForm } from "react-hook-form"; import { zodResolver } from "@hookform/resolvers/zod"; import { NoteFormValues, noteSchema } from "@/lib/validators"; import { updateNote } from "@/actions/notes"; import { useToast } from "@/hooks/use-toast"; import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle, } from "@/components/ui/dialog"; import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage, } from "@/components/ui/form"; import { Textarea } from "@/components/ui/textarea"; import { Button } from "@/components/ui/button"; interface Note { id: string; content: string; } interface EditNoteFormProps { note: Note; entityType: "stock" | "transaction"; entityId: string; open: boolean; onOpenChange: (open: boolean) => void; } export default function EditNoteForm({ note, entityType, entityId, open, onOpenChange, }: EditNoteFormProps) { const { toast } = useToast(); const [isLoading, setIsLoading] = useState(false); const form = useForm<NoteFormValues>({ resolver: zodResolver(noteSchema), defaultValues: { content: note.content, stockId: entityType === "stock" ? entityId : undefined, transactionId: entityType === "transaction" ? entityId : undefined, }, }); // Update form values when note changes useEffect(() => { form.reset({ content: note.content, stockId: entityType === "stock" ? entityId : undefined, transactionId: entityType === "transaction" ? entityId : undefined, }); }, [note, entityType, entityId, form]); const onSubmit = async (data: NoteFormValues) => { setIsLoading(true); try { const result = await updateNote(note.id, data); if (result.success) { toast({ title: "Note updated", description: "Your note has been updated successfully.", }); onOpenChange(false); } else { toast({ title: "Error", description: result.error || "Failed to update note.", variant: "destructive", }); } } catch (error) { toast({ title: "Error", description: "An unexpected error occurred.", variant: "destructive", }); } finally { setIsLoading(false); } }; return ( <Dialog open={open} onOpenChange={onOpenChange}> <DialogContent> <DialogHeader> <DialogTitle>Edit Note</DialogTitle> <DialogDescription> Update your note for this {entityType} </DialogDescription> </DialogHeader> <Form {...form}> <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4"> <input type="hidden" {...form.register("stockId")} value={entityType === "stock" ? entityId : ""} /> <input type="hidden" {...form.register("transactionId")} value={entityType === "transaction" ? entityId : ""} /> <FormField control={form.control} name="content" render={({ field }) => ( <FormItem> <FormLabel>Note</FormLabel> <FormControl> <Textarea placeholder="Enter your notes here..." className="min-h-32" {...field} /> </FormControl> <FormMessage /> </FormItem> )} /> <DialogFooter> <Button type="button" variant="outline" onClick={() => onOpenChange(false)} disabled={isLoading} > Cancel </Button> <Button type="submit" disabled={isLoading}> {isLoading ? "Saving..." : "Save Changes"} </Button> </DialogFooter> </form> </Form> </DialogContent> </Dialog> ); }
```

# src/components/notes/delete-note-form.tsx

```tsx
"use client"; import { useState } from "react"; import { deleteNote } from "@/actions/notes"; import { useToast } from "@/hooks/use-toast"; import { AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle, } from "@/components/ui/alert-dialog"; import { Button } from "@/components/ui/button"; interface Note { id: string; content: string; } interface DeleteNoteDialogProps { note: Note; open: boolean; onOpenChange: (open: boolean) => void; } export default function DeleteNoteDialog({ note, open, onOpenChange, }: DeleteNoteDialogProps) { const { toast } = useToast(); const [isLoading, setIsLoading] = useState(false); const handleDelete = async () => { setIsLoading(true); try { const result = await deleteNote(note.id); if (result.success) { toast({ title: "Note deleted", description: "Your note has been deleted successfully.", }); onOpenChange(false); } else { toast({ title: "Error", description: result.error || "Failed to delete note.", variant: "destructive", }); } } catch (error) { toast({ title: "Error", description: "An unexpected error occurred.", variant: "destructive", }); } finally { setIsLoading(false); } }; return ( <AlertDialog open={open} onOpenChange={onOpenChange}> <AlertDialogContent> <AlertDialogHeader> <AlertDialogTitle>Delete Note</AlertDialogTitle> <AlertDialogDescription> Are you sure you want to delete this note? This action cannot be undone. </AlertDialogDescription> </AlertDialogHeader> <AlertDialogFooter> <AlertDialogCancel disabled={isLoading}>Cancel</AlertDialogCancel> <Button variant="destructive" onClick={handleDelete} disabled={isLoading} > {isLoading ? "Deleting..." : "Delete"} </Button> </AlertDialogFooter> </AlertDialogContent> </AlertDialog> ); }
```

# src/components/notes/delete-note-dialog.tsx

```tsx
"use client"; import { useState } from "react"; import { deleteNote } from "@/actions/notes"; import { useToast } from "@/hooks/use-toast"; import { AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle, } from "@/components/ui/alert-dialog"; import { Button } from "@/components/ui/button"; interface Note { id: string; content: string; } interface DeleteNoteDialogProps { note: Note; open: boolean; onOpenChange: (open: boolean) => void; } export default function DeleteNoteDialog({ note, open, onOpenChange, }: DeleteNoteDialogProps) { const { toast } = useToast(); const [isLoading, setIsLoading] = useState(false); const handleDelete = async () => { setIsLoading(true); try { const result = await deleteNote(note.id); if (result.success) { toast({ title: "Note deleted", description: "Your note has been deleted successfully.", }); onOpenChange(false); } else { toast({ title: "Error", description: result.error || "Failed to delete note.", variant: "destructive", }); } } catch (error) { toast({ title: "Error", description: "An unexpected error occurred.", variant: "destructive", }); } finally { setIsLoading(false); } }; return ( <AlertDialog open={open} onOpenChange={onOpenChange}> <AlertDialogContent> <AlertDialogHeader> <AlertDialogTitle>Delete Note</AlertDialogTitle> <AlertDialogDescription> Are you sure you want to delete this note? This action cannot be undone. </AlertDialogDescription> </AlertDialogHeader> <AlertDialogFooter> <AlertDialogCancel disabled={isLoading}>Cancel</AlertDialogCancel> <Button variant="destructive" onClick={handleDelete} disabled={isLoading} > {isLoading ? "Deleting..." : "Delete"} </Button> </AlertDialogFooter> </AlertDialogContent> </AlertDialog> ); }
```

# src/components/notes/add-note-form.tsx

```tsx
"use client"; import { useState } from "react"; import { useForm } from "react-hook-form"; import { zodResolver } from "@hookform/resolvers/zod"; import { NoteFormValues, noteSchema } from "@/lib/validators"; import { createNote } from "@/actions/notes"; import { useToast } from "@/hooks/use-toast"; import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle, } from "@/components/ui/dialog"; import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage, } from "@/components/ui/form"; import { Textarea } from "@/components/ui/textarea"; import { Button } from "@/components/ui/button"; interface AddNoteFormProps { entityType: "stock" | "transaction"; entityId: string; open: boolean; onOpenChange: (open: boolean) => void; } export default function AddNoteForm({ entityType, entityId, open, onOpenChange, }: AddNoteFormProps) { const { toast } = useToast(); const [isLoading, setIsLoading] = useState(false); const form = useForm<NoteFormValues>({ resolver: zodResolver(noteSchema), defaultValues: { content: "", stockId: entityType === "stock" ? entityId : undefined, transactionId: entityType === "transaction" ? entityId : undefined, }, }); const onSubmit = async (data: NoteFormValues) => { setIsLoading(true); try { const result = await createNote(data); if (result.success) { toast({ title: "Note added", description: "Your note has been added successfully.", }); form.reset(); onOpenChange(false); } else { toast({ title: "Error", description: result.error || "Failed to add note.", variant: "destructive", }); } } catch (error) { toast({ title: "Error", description: "An unexpected error occurred.", variant: "destructive", }); } finally { setIsLoading(false); } }; return ( <Dialog open={open} onOpenChange={onOpenChange}> <DialogContent> <DialogHeader> <DialogTitle>Add Note</DialogTitle> <DialogDescription> Add a new note for this {entityType} </DialogDescription> </DialogHeader> <Form {...form}> <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4"> <input type="hidden" {...form.register("stockId")} value={entityType === "stock" ? entityId : ""} /> <input type="hidden" {...form.register("transactionId")} value={entityType === "transaction" ? entityId : ""} /> <FormField control={form.control} name="content" render={({ field }) => ( <FormItem> <FormLabel>Note</FormLabel> <FormControl> <Textarea placeholder="Enter your notes here..." className="min-h-32" {...field} /> </FormControl> <FormMessage /> </FormItem> )} /> <DialogFooter> <Button type="button" variant="outline" onClick={() => onOpenChange(false)} disabled={isLoading} > Cancel </Button> <Button type="submit" disabled={isLoading}> {isLoading ? "Adding..." : "Add Note"} </Button> </DialogFooter> </form> </Form> </DialogContent> </Dialog> ); }
```

# src/components/layout/navigation.tsx

```tsx
"use client"; import Link from "next/link"; import { usePathname } from "next/navigation"; import { cn } from "@/lib/utils"; import { BarChart3, BookOpen, CreditCard, LineChart, Settings, } from "lucide-react"; import { ModeToggle } from "@/components/ui/mode-toggle"; interface NavigationItem { title: string; href: string; icon: React.ReactNode; } export default function Navigation() { const pathname = usePathname(); const navigationItems: NavigationItem[] = [ { title: "Dashboard", href: "/dashboard", icon: <BarChart3 className="w-5 h-5" />, }, { title: "Stocks", href: "/stocks", icon: <LineChart className="w-5 h-5" />, }, { title: "Transactions", href: "/transactions", icon: <CreditCard className="w-5 h-5" />, }, { title: "Notes", href: "/notes", icon: <BookOpen className="w-5 h-5" />, }, { title: "Settings", href: "/settings", icon: <Settings className="w-5 h-5" />, }, ]; return ( <header className= "sticky top-0 z-50 w-full border-b bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60" > <div className="container flex h-16 items-center" > <div className="flex items-center gap-2 font-bold text-lg mr-4" > <LineChart className="h-6 w-6" /> <span>StockManager </span> </div> < nav className = "flex items-center space-x-4 lg:space-x-6 mx-6" > { navigationItems.map((item) => ( <Link key= { item.href } href = { item.href } className = { cn( "flex items-center text-sm font-medium transition-colors hover:text-primary", pathname === item.href ? "text-foreground" : "text-muted-foreground" ) } > { item.icon } < span className = "ml-2" > { item.title } </span> </Link> )) } </nav> < div className = "ml-auto flex items-center space-x-4" > <ModeToggle /> </div> </div> </header> ); }
```

# prisma/migrations/20250415165931_add_transaction_fields/migration.sql

```sql
-- CreateTable CREATE TABLE "User" ( "id" TEXT NOT NULL PRIMARY KEY, "name" TEXT NOT NULL, "email" TEXT NOT NULL, "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ); -- CreateTable CREATE TABLE "Stock" ( "id" TEXT NOT NULL PRIMARY KEY, "ticker" TEXT NOT NULL, "name" TEXT NOT NULL, "sectorId" TEXT, "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP, "userId" TEXT NOT NULL, CONSTRAINT "Stock_sectorId_fkey" FOREIGN KEY ("sectorId") REFERENCES "Sector" ("id") ON DELETE SET NULL ON UPDATE CASCADE, CONSTRAINT "Stock_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User" ("id") ON DELETE RESTRICT ON UPDATE CASCADE ); -- CreateTable CREATE TABLE "Transaction" ( "id" TEXT NOT NULL PRIMARY KEY, "stockId" TEXT NOT NULL, "userId" TEXT NOT NULL, "type" TEXT NOT NULL, "quantity" REAL NOT NULL, "price" REAL NOT NULL, "exchangeRate" REAL NOT NULL, "fxFee" REAL NOT NULL, "date" DATETIME NOT NULL, CONSTRAINT "Transaction_stockId_fkey" FOREIGN KEY ("stockId") REFERENCES "Stock" ("id") ON DELETE RESTRICT ON UPDATE CASCADE, CONSTRAINT "Transaction_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User" ("id") ON DELETE RESTRICT ON UPDATE CASCADE ); -- CreateTable CREATE TABLE "Note" ( "id" TEXT NOT NULL PRIMARY KEY, "content" TEXT NOT NULL, "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP, "stockId" TEXT, "transactionId" TEXT, "userId" TEXT NOT NULL, CONSTRAINT "Note_stockId_fkey" FOREIGN KEY ("stockId") REFERENCES "Stock" ("id") ON DELETE SET NULL ON UPDATE CASCADE, CONSTRAINT "Note_transactionId_fkey" FOREIGN KEY ("transactionId") REFERENCES "Transaction" ("id") ON DELETE SET NULL ON UPDATE CASCADE, CONSTRAINT "Note_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User" ("id") ON DELETE RESTRICT ON UPDATE CASCADE ); -- CreateTable CREATE TABLE "Sector" ( "id" TEXT NOT NULL PRIMARY KEY, "name" TEXT NOT NULL ); -- CreateTable CREATE TABLE "AuditLog" ( "id" TEXT NOT NULL PRIMARY KEY, "action" TEXT NOT NULL, "entityType" TEXT NOT NULL, "entityId" TEXT NOT NULL, "payload" TEXT NOT NULL, "timestamp" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP, "userId" TEXT NOT NULL ); -- CreateIndex CREATE UNIQUE INDEX "User_email_key" ON "User"("email"); -- CreateIndex CREATE UNIQUE INDEX "Sector_name_key" ON "Sector"("name");
```

# src/components/dashboard/stock-summary.tsx

```tsx
"use client"; import { useState } from "react"; import Link from "next/link"; import { Card, CardContent, CardDescription, CardHeader, CardTitle, } from "@/components/ui/card"; import { Input } from "@/components/ui/input"; import { formatCurrency } from "@/lib/utils"; interface Stock { id: string; ticker: string; name: string; sector?: { id: string; name: string; } | null; averagePrice: number; holdings: number; value: number; } interface StockSummaryProps { stocks: Stock[]; } export default function StockSummary({ stocks }: StockSummaryProps) { const [search, setSearch] = useState(""); const filteredStocks = stocks.filter((stock) => { const searchLower = search.toLowerCase(); return ( stock.ticker.toLowerCase().includes(searchLower) || stock.name.toLowerCase().includes(searchLower) || stock.sector?.name.toLowerCase().includes(searchLower) ); }); // Sort by value (descending) const sortedStocks = [...filteredStocks].sort((a, b) => b.value - a.value); return ( <Card className="col-span-full"> <CardHeader className="space-y-0"> <div className="flex items-center justify-between"> <div> <CardTitle>Stock Holdings</CardTitle> <CardDescription> Your current stock positions and values </CardDescription> </div> <div className="w-64"> <Input placeholder="Search stocks..." value={search} onChange={(e) => setSearch(e.target.value)} className="w-full" /> </div> </div> </CardHeader> <CardContent> <div className="overflow-x-auto"> <table className="w-full text-sm"> <thead> <tr className="border-b"> <th className="text-left font-medium py-3 px-2">Ticker</th> <th className="text-left font-medium py-3 px-2">Company</th> <th className="text-left font-medium py-3 px-2">Sector</th> <th className="text-right font-medium py-3 px-2">Avg Price</th> <th className="text-right font-medium py-3 px-2">Shares</th> <th className="text-right font-medium py-3 px-2">Current Value</th> </tr> </thead> <tbody className="divide-y"> {sortedStocks.length === 0 ? ( <tr> <td colSpan={6} className="py-6 text-center text-muted-foreground"> {search ? "No stocks match your search" : "No stocks in your portfolio yet"} </td> </tr> ) : ( sortedStocks.map((stock) => ( <tr key={stock.id} className="hover:bg-muted/50"> <td className="py-3 px-2"> <Link href={`/stocks/${stock.id}`} className="font-medium hover:underline" > {stock.ticker} </Link> </td> <td className="py-3 px-2">{stock.name}</td> <td className="py-3 px-2">{stock.sector?.name || "—"}</td> <td className="py-3 px-2 text-right"> {formatCurrency(stock.averagePrice)} </td> <td className="py-3 px-2 text-right">{stock.holdings.toFixed(2)}</td> <td className="py-3 px-2 text-right font-medium"> {formatCurrency(stock.value)} </td> </tr> )) )} </tbody> </table> </div> </CardContent> </Card> ); }
```

# src/components/dashboard/sector-breakdown.tsx

```tsx
"use client"; import { Card, CardContent, CardDescription, CardHeader, CardTitle, } from "@/components/ui/card"; import { formatCurrency } from "@/lib/utils"; import { PieChart, Pie, Cell, ResponsiveContainer, Tooltip } from "recharts"; interface SectorBreakdownProps { sectors: { name: string; value: number; percentage: number; }[]; currency?: string; // Add currency prop with optional marker } // Generate colors for the pie chart const COLORS = [ "#0088FE", "#00C49F", "#FFBB28", "#FF8042", "#A020F0", "#00BFFF", "#8884D8", "#82CA9D", "#FF6B6B", "#FFA07A" ]; export default function SectorBreakdown({ sectors, currency = 'GBP' }: SectorBreakdownProps) { // If no sectors, display a fallback if (sectors.length === 0) { return ( <Card> <CardHeader> <CardTitle>Sector Breakdown</CardTitle> <CardDescription>Allocation by industry sector</CardDescription> </CardHeader> <CardContent className="flex items-center justify-center h-48"> <p className="text-muted-foreground">No sector data available</p> </CardContent> </Card> ); } return ( <Card> <CardHeader> <CardTitle>Sector Breakdown</CardTitle> <CardDescription>Allocation by industry sector</CardDescription> </CardHeader> <CardContent> <div className="h-48 w-full"> <ResponsiveContainer width="100%" height="100%"> <PieChart> <Pie data={sectors} cx="50%" cy="50%" innerRadius={30} outerRadius={70} paddingAngle={2} dataKey="value" nameKey="name" label={({ name, percent }) => `${name} ${(percent * 100).toFixed(0)}%`} labelLine={false} > {sectors.map((entry, index) => ( <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} /> ))} </Pie> <Tooltip formatter={(value: number) => formatCurrency(value, currency)} /> </PieChart> </ResponsiveContainer> </div> <div className="mt-2 space-y-1"> {sectors.map((sector, index) => ( <div key={sector.name} className="flex items-center text-xs"> <div className="w-3 h-3 mr-1" style={{ backgroundColor: COLORS[index % COLORS.length] }} /> <div className="flex-1 font-medium">{sector.name}</div> <div>{formatCurrency(sector.value, currency)}</div> </div> ))} </div> </CardContent> </Card> ); }
```

# src/components/dashboard/recent-transactions.tsx

```tsx
import Link from "next/link"; import { formatCurrency, formatDate, getCurrencySymbol, } from "@/lib/utils"; import { ArrowDownIcon, ArrowUpIcon, CurrencyIcon, } from "lucide-react"; import React from "react"; import { Card, CardContent, CardDescription, CardHeader, CardTitle, } from "@/components/ui/card"; import { TransactionType } from "@/lib/constants"; import { Currency } from "@/lib/validators"; interface Transaction { id: string; date: Date; type: string; quantity: number; price: number; currency: Currency; stock: { id: string; ticker: string; name: string }; } interface RecentTransactionsProps { transactions: Transaction[]; /** user’s base currency (defaults to GBP) */ baseCurrency?: Currency; } export default function RecentTransactions({ transactions, baseCurrency = "GBP" as Currency, }: RecentTransactionsProps) { return ( <Card> <CardHeader> <CardTitle>Recent Transactions</CardTitle> <CardDescription>Your latest stock trades</CardDescription> </CardHeader> <CardContent> {transactions.length === 0 ? ( <p className="py-6 text-center text-sm text-muted-foreground"> No recent transactions </p> ) : ( <div className="space-y-4"> {transactions.map((t) => { const isBuy = t.type === TransactionType.BUY; const foreign = t.currency !== baseCurrency; return ( <div key={t.id} className="flex items-center"> <div className={`mr-3 flex h-9 w-9 items-center justify-center rounded-full ${isBuy ? "bg-green-100 dark:bg-green-900" : "bg-red-100 dark:bg-red-900" }`} > {isBuy ? ( <ArrowDownIcon className="h-4 w-4 text-green-600 dark:text-green-400" /> ) : ( <ArrowUpIcon className="h-4 w-4 text-red-600 dark:text-red-400" /> )} </div> <div className="flex-1 space-y-1"> <div className="flex items-center"> <Link href={`/transactions/${t.id}`} className="text-sm font-medium leading-none hover:underline" > {isBuy ? "Bought" : "Sold"} {t.stock.ticker} </Link> <div className="ml-auto text-xs text-muted-foreground"> {formatDate(t.date)} </div> </div> <p className="flex items-center gap-1 text-xs text-muted-foreground"> {t.quantity.toFixed(2)} shares @{" "} {formatCurrency(t.price, t.currency)} {foreign && ( <CurrencyIcon className="h-3 w-3 text-blue-500 dark:text-blue-400" /> )} </p> </div> </div> ); })} </div> )} <div className="mt-4 border-t pt-4"> <Link href="/transactions" className="text-xs text-blue-500 hover:underline dark:text-blue-400" > View all transactions </Link> </div> </CardContent> </Card> ); }
```

# src/components/dashboard/portfolio-value.tsx

```tsx
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"; import { formatCurrency, getCurrencySymbol } from "@/lib/utils"; import { Landmark } from "lucide-react"; interface PortfolioValueProps { portfolioValue: number; stocksCount: number; currency: string; } export default function PortfolioValue({ portfolioValue, stocksCount, currency, }: PortfolioValueProps) { return ( <Card> <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2"> <CardTitle className="text-sm font-medium">Portfolio Value</CardTitle> <Landmark className="h-4 w-4 text-muted-foreground" /> </CardHeader> <CardContent> <div className="text-2xl font-bold">{formatCurrency(portfolioValue, currency)}</div> <p className="text-xs text-muted-foreground"> {stocksCount} {stocksCount === 1 ? "stock" : "stocks"} in portfolio <span className="ml-1">({getCurrencySymbol(currency)} {currency})</span> </p> </CardContent> </Card> ); }
```

# src/components/dashboard/dashboard-header.tsx

```tsx
import { formatCurrency } from "@/lib/utils"; interface DashboardHeaderProps { username: string; portfolioValue: number; currency: string; } export default function DashboardHeader({ username, portfolioValue, currency, }: DashboardHeaderProps) { return ( <div className="space-y-0.5"> <h2 className="text-2xl font-bold tracking-tight">Welcome back, {username}</h2> <div className="flex items-center text-muted-foreground"> <span>Your portfolio is currently worth {formatCurrency(portfolioValue, currency)}</span> </div> </div> ); }
```

# src/app/transactions/[id]/page.tsx

```tsx
import { Metadata } from "next"; import { notFound } from "next/navigation"; import Link from "next/link"; import { getTransactionById } from "@/actions/transactions"; import { Card, CardContent, CardDescription, CardHeader, CardTitle, } from "@/components/ui/card"; import { formatCurrency, formatDate, calculateTransactionTotal, getCurrencySymbol, } from "@/lib/utils"; import { ArrowDownIcon, ArrowUpIcon, ChevronLeftIcon, } from "lucide-react"; import { TransactionType } from "@/lib/constants"; import TransactionActions from "@/components/transactions/transaction-actions"; import TransactionNotes from "@/components/transactions/transaction-notes"; import { getCurrentUser } from "@/actions/user"; import { Currency } from "@/lib/validators"; // Import the specific interface TransactionActions expects import { EditFormTransaction } from "@/components/transactions/edit-transaction-form"; interface TransactionPageProps { params: { id: string }; } export async function generateMetadata({ params, }: TransactionPageProps): Promise<Metadata> { const { success, data, error } = await getTransactionById(params.id); if (!success || !data) { return { title: "Transaction Not Found | Stock Manager", }; } return { title: `${data.type} ${data.stock.ticker} | Stock Manager`, description: `Transaction details for ${data.stock.ticker}`, }; } export default async function TransactionPage({ params }: TransactionPageProps) { const { success, data: transactionFromDb, error } = await getTransactionById( params.id ); const user = await getCurrentUser(); const userCurrency = (user.defaultCurrency || "GBP") as Currency; // Cast user currency if (!success || !transactionFromDb) { notFound(); } const isBuy = transactionFromDb.type === TransactionType.BUY; const transactionCurrency = (transactionFromDb.currency || transactionFromDb.stock.currency || "USD") as Currency; // Determine and cast transaction currency const total = calculateTransactionTotal(transactionFromDb); const isForeignCurrency = transactionCurrency !== userCurrency; // Create a correctly typed transaction object conforming to EditFormTransaction const typedTransactionForActions: EditFormTransaction = { id: transactionFromDb.id, type: transactionFromDb.type, quantity: transactionFromDb.quantity, price: transactionFromDb.price, currency: transactionCurrency, // Use the casted transaction currency exchangeRate: transactionFromDb.exchangeRate, // Already number | null fxFee: transactionFromDb.fxFee, // Already number | null date: transactionFromDb.date, // Already Date stock: { id: transactionFromDb.stock.id, ticker: transactionFromDb.stock.ticker, name: transactionFromDb.stock.name, currency: (transactionFromDb.stock.currency || "USD") as Currency, // Cast nested stock currency }, // Note: EditFormTransaction doesn't include notes, so we don't pass them here }; return ( <div className="space-y-6"> <div className="flex flex-col gap-4 sm:flex-row sm:items-center sm:justify-between"> <div> <Link href="/transactions" className="inline-flex items-center gap-1 text-sm text-muted-foreground hover:text-foreground mb-2" > <ChevronLeftIcon className="h-4 w-4" /> Back to Transactions </Link> <h2 className="text-2xl font-bold tracking-tight"> {isBuy ? "Buy" : "Sell"} Transaction: {transactionFromDb.stock.ticker} </h2> <p className="text-muted-foreground"> {formatDate(transactionFromDb.date)} </p> </div> {/* Pass the correctly typed transaction object */} <TransactionActions transaction={typedTransactionForActions} /> </div> <Card> <CardHeader> <div className="flex items-center gap-3"> <div className={`flex h-9 w-9 items-center justify-center rounded-full ${isBuy ? "bg-green-100 dark:bg-green-900" : "bg-red-100 dark:bg-red-900" }`} > {isBuy ? ( <ArrowDownIcon className="h-4 w-4 text-green-600 dark:text-green-400" /> ) : ( <ArrowUpIcon className="h-4 w-4 text-red-600 dark:text-red-400" /> )} </div> <CardTitle>Transaction Details</CardTitle> </div> <CardDescription> <Link href={`/stocks/${transactionFromDb.stock.id}`} className="hover:underline" > {transactionFromDb.stock.ticker}: {transactionFromDb.stock.name} </Link> </CardDescription> </CardHeader> <CardContent> <div className="grid grid-cols-2 gap-4 sm:grid-cols-4"> <div> <div className="text-sm font-medium text-muted-foreground">Type</div> <div className="text-lg font-medium">{isBuy ? "Buy" : "Sell"}</div> </div> <div> <div className="text-sm font-medium text-muted-foreground">Quantity</div> <div className="text-lg font-medium"> {transactionFromDb.quantity.toFixed(2)} </div> </div> <div> <div className="text-sm font-medium text-muted-foreground">Price</div> <div className="text-lg font-medium"> {/* Use transactionCurrency for formatting price */} {formatCurrency(transactionFromDb.price, transactionCurrency)} </div> </div> <div> <div className="text-sm font-medium text-muted-foreground">Total</div> <div className="text-lg font-medium"> {formatCurrency(total, userCurrency)} </div> </div> </div> {isForeignCurrency && ( <div className="mt-4 pt-4 border-t"> <h3 className="font-medium mb-2">Currency Details</h3> <div className="grid grid-cols-2 gap-4 sm:grid-cols-4"> <div> <div className="text-sm font-medium text-muted-foreground"> Transaction Currency </div> <div className="text-lg font-medium"> {getCurrencySymbol(transactionCurrency)} {transactionCurrency} </div> </div> <div> <div className="text-sm font-medium text-muted-foreground"> Base Currency </div> <div className="text-lg font-medium"> {getCurrencySymbol(userCurrency)} {userCurrency} </div> </div> <div> <div className="text-sm font-medium text-muted-foreground"> Exchange Rate </div> <div className="text-lg font-medium"> {transactionFromDb.exchangeRate?.toFixed(4)} </div> </div> <div> <div className="text-sm font-medium text-muted-foreground">FX Fee</div> <div className="text-lg font-medium"> {transactionFromDb.fxFee ? formatCurrency(transactionFromDb.fxFee, userCurrency) : `${getCurrencySymbol(userCurrency)}0.00`} </div> </div> <div className="col-span-full"> <div className="text-sm font-medium text-muted-foreground"> Calculation </div> <div className="text-sm text-muted-foreground"> {transactionFromDb.quantity.toFixed(2)} ×{" "} {formatCurrency(transactionFromDb.price, transactionCurrency)} ×{" "} {transactionFromDb.exchangeRate?.toFixed(4)}{" "} {transactionFromDb.fxFee ? (isBuy ? " + " : " - ") + formatCurrency(transactionFromDb.fxFee || 0, userCurrency) + " fee" : ""}{" "} {" = "}{formatCurrency(total, userCurrency)} </div> </div> </div> </div> )} </CardContent> </Card> <TransactionNotes transactionId={transactionFromDb.id} notes={transactionFromDb.notes || []} /> </div> ); }
```

# src/app/stocks/[id]/page.tsx

```tsx
// src/app/stocks/[id]/page.tsx import { Metadata } from "next"; import { notFound } from "next/navigation"; import { getStockById } from "@/actions/stocks"; import { calculateAveragePrice, calculateTotalHoldings } from "@/lib/utils"; import StockHeader from "@/components/stocks/stock-header"; import StockDetails from "@/components/stocks/stock-details"; import StockTransactions from "@/components/stocks/stock-transactions"; import StockNotes from "@/components/stocks/stock-notes"; import { Currency } from "@/lib/validators"; // Import the Currency type interface StockPageProps { params: { id: string }; } export async function generateMetadata({ params, }: StockPageProps): Promise<Metadata> { const { success, data, error } = await getStockById(params.id); if (!success || !data) { return { title: "Stock Not Found | Stock Manager", }; } return { title: `${data.ticker} | Stock Manager`, description: `Details for ${data.name} (${data.ticker})`, }; } export default async function StockPage({ params }: StockPageProps) { const { success, data: stock, error } = await getStockById(params.id); if (!success || !stock) { notFound(); } // Calculate stock details const averagePrice = calculateAveragePrice(stock.transactions); const holdings = calculateTotalHoldings(stock.transactions); const value = holdings * averagePrice; // Note: This assumes average price reflects current value // Enhance the stock object and cast the currency type const enhancedStock = { ...stock, averagePrice, holdings, value, currency: (stock.currency || "USD") as Currency, // Cast stock currency notes: stock.notes || [], }; // Map over transactions to cast their currency type const typedTransactions = stock.transactions.map((tx) => ({ ...tx, currency: (tx.currency || stock.currency || "USD") as Currency, // Cast transaction currency })); // Log for debugging console.log(`Stock ${stock.ticker} has ${stock.notes?.length || 0} notes`); return ( <div className="space-y-6"> <StockHeader stock={enhancedStock} /> <div className="grid gap-6 md:grid-cols-7"> <div className="md:col-span-3"> <StockDetails stock={enhancedStock} /> </div> <div className="md:col-span-4"> <StockTransactions stock={enhancedStock} transactions={typedTransactions} // <-- Pass the correctly typed transactions /> </div> </div> <StockNotes stockId={stock.id} notes={stock.notes || []} /> </div> ); }
```

# src/app/notes/[id]/page.tsx

```tsx
import { Metadata } from "next"; import { notFound } from "next/navigation"; import Link from "next/link"; import { getNoteById } from "@/actions/notes"; import { Button } from "@/components/ui/button"; import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"; import { formatDate } from "@/lib/utils"; import { ChevronLeftIcon } from "lucide-react"; import NoteActions from "@/components/notes/note-actions"; interface NotePageProps { params: { id: string; }; } export async function generateMetadata({ params }: NotePageProps): Promise<Metadata> { const { success, data, error } = await getNoteById(params.id); if (!success || !data) { return { title: "Note Not Found | Stock Manager", }; } return { title: `Note | Stock Manager`, description: `View note details`, }; } export default async function NotePage({ params }: NotePageProps) { const { success, data: note, error } = await getNoteById(params.id); if (!success || !note) { notFound(); } return ( <div className="space-y-6"> <div className="flex flex-col gap-4 sm:flex-row sm:items-center sm:justify-between"> <div> <Link href="/notes" className="inline-flex items-center gap-1 text-sm text-muted-foreground hover:text-foreground mb-2" > <ChevronLeftIcon className="h-4 w-4" /> Back to Notes </Link> <h2 className="text-2xl font-bold tracking-tight">Note Details</h2> </div> <NoteActions note={note} /> </div> <Card> <CardHeader> <CardTitle className="flex items-center justify-between"> <div> {note.stock ? ( <Link href={`/stocks/${note.stock.id}`} className="hover:underline"> {note.stock.ticker}: {note.stock.name} </Link> ) : note.transaction ? ( <Link href={`/transactions/${note.transaction.id}`} className="hover:underline"> Transaction for {note.transaction.stock.ticker} </Link> ) : ( "General Note" )} </div> <div className="text-sm font-normal text-muted-foreground"> {formatDate(note.createdAt)} </div> </CardTitle> <CardDescription> {note.stock ? `Note for ${note.stock.ticker}` : note.transaction ? `Note for transaction of ${note.transaction.stock.ticker}` : "General investment note"} </CardDescription> </CardHeader> <CardContent> <div className="whitespace-pre-wrap">{note.content}</div> </CardContent> </Card> </div> ); }
```

